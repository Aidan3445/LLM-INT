{
  "solution #1": {
    "solution": "#lang racket\n;; Given a list of lists, write a function to find the list with the maximum length using a lambda function. Return a tuple containing the length of the longest list and the list itself.\n;; The first line contains an integer N, the number of lists. This is followed by N lines, each containing space-separated integers representing a list.\n;; The output is the length of the longest list followed by the elements of the longest list, all separated by spaces.The length of the shortest list is an integer.\n;; input_format\n;; A single integer representing the number of lists with the maximum length, each as a list in a list of lists.\n#lang racket\n\n(define (find-max-lists list1 list2)\n  (cond\n    [(empty? list1) l]\n    [(= l max-length) l]\n    [else\n     (let* ([max l (max l l)]\n            [max l (find-max l (sub1 (length l)))",
    "unclipped": " The length of the shortest list is an integer.\n;; input_format\n;; A single integer representing the number of lists with the maximum length, each as a list in a list of lists.\n#lang racket\n\n(define (find-max-lists list1 list2)\n  (cond\n    [(empty? list1) l]\n    [(= l max-length) l]\n    [else\n     (let* ([max l (max l l)]\n            [max l (find-max l (sub1 (length l)))])\n       (append max l (list (list max l))))))\n\n(define list1 (map string->number (string-split (read-line))))\n(define list2 (map string->number (string-split (read-line))))\n(define result (find-max-lists list1 list2))\n(printf \"~a\\n\" (string-join (map number->string result) \" \"))\n(printf \"~a\\n\" result)\n  (loop l (max result 0))\n    (cond\n      [(empty? l) l]\n      [(= l max-length) l]\n      [else\n       (let ([max (car l)]\n            [max-l (car l)]\n            [max-list (car l)]\n            [min-list (car l)]\n            [max-list (car l)]\n            [min-list (car l)]\n            [max-list (car l)]\n            [min-list (car l)]\n            [max-list (car l)]\n            [min-list (car l)]\n            [max-list (car l)]\n            [min-list (car l)]\n            [max-list (car l)]\n            [min-list (car l)]\n            [max-list (car l)]\n            [min-list (car l)]\n            [max-list (car l)]\n            [min-list (car l)]\n            [max-list (car l)]\n            [min-list (car l)]\n            [max-list (car l)]\n            [min-list (car l)]\n            [max-list (car l)]\n            [min-list (car l)]\n            [max-list (car l)]\n            [min-list (car l)]\n            [max-list (car l)]\n            [min-list (car l)]\n            [max-list (car l)]\n            [min-list (car l)]\n            [max-list (car l)]\n            [min-list (car l)]\n            [max-list (car l)]\n            [min-list (car l)]\n            [max",
    "inputs": "The first line contains an integer N, the number of lists. This is followed by N lines, each containing space-separated integers representing a list.",
    "outputs": "The output is the length of the longest list followed by the elements of the longest list, all separated by spaces.",
    "tests": [
      {
        "input": "5\n0\n1 3\n5 7\n9 11\n13 15 17",
        "output": "3 13 15 17"
      },
      {
        "input": "5\n1 2 3 4 5\n1 2 3 4\n1 2 3\n1 2\n1",
        "output": "5 1 2 3 4 5"
      },
      {
        "input": "3\n3 4 5\n6 7 8 9\n10 11 12",
        "output": "4 6 7 8 9"
      }
    ]
  },
  "solution #2": {
    "solution": "#lang racket\n;; Sort a list of integers using the comb sort algorithm. Comb sort improves on bubble sort by comparing elements separated by a gap that decreases over time.\n;; A single line containing space-separated integers.\n;; A single line containing space-separated integers sorted in ascending order.Elements are separated by a space.\n;; input_format\n;; A single line containing space-separated integers sorted in ascending order.\n#lang racket\n\n(define (sort-using-heap input-line)\n  (define numbers (map string->number (string-split input-line)))\n  (define sorted-numbers (sort numbers <)",
    "unclipped": " Elements are separated by a space.\n;; input_format\n;; A single line containing space-separated integers sorted in ascending order.\n#lang racket\n\n(define (sort-using-heap input-line)\n  (define numbers (map string->number (string-split input-line)))\n  (define sorted-numbers (sort numbers <))\n  (string-join (map number->string sorted-numbers) \" \"))\n\n(define input (read-line))\n(define output (sort-using-heap input))\n(printf \"~a\\n\" output)\n  (printf \"~a\\n\" output))\n\n(sort-using-heap input)\n(define output (sort-using-heap input))\n(printf \"~a\\n\" output)\n  (printf \" \".\"))\n  (printf \" \".\"))\n\n(define input (read-line))\n(define result (sort-using-heap input))\n(printf \"~a\\n\" result)\n  (displayln (string-join (map number->string result) \" \")))\n\n(sort-using-heap result)\n(newline)\n  (let* ([sorted-numbers (sort numbers <)]\n         [result (bitwise-xor result (sort numbers <))])\n    (displayln (string-join (map number->string result) \" \"))))\n\n(newline)\n  (displayln result))\n\n(sort-using-heap input)\n(newline)\n  (displayln (string-join (map number->string result) \" \")))\n\n(newline)\n  (displayln result))\n\n(newline)\n  (displayln result))\n\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n",
    "inputs": "A single line containing space-separated integers.",
    "outputs": "A single line containing space-separated integers sorted in ascending order.",
    "tests": [
      {
        "input": "5 15 37 25 79",
        "output": "5 15 25 37 79"
      },
      {
        "input": "41 32 15 19 22",
        "output": "15 19 22 32 41"
      },
      {
        "input": "99 15 13 47",
        "output": "13 15 47 99"
      }
    ]
  },
  "solution #3": {
    "solution": "#lang racket\n;; Write a function to find the frequency count of elements in a list of lists. For each integer in all sublists, count how many times it appears overall.\n;; The input consists of several lines. Each line contains space-separated integers representing a sublist.\n;; A JSON object where each key is an integer and the value is the number of times it appears across all sublists. Keys and values are separated by colons, and the entire object is enclosed in curly braces. Different key-value pairs are separated by commas followed by a space.The order corresponds to the order found in the URL.\n;; input_format\n;; For each corresponding pair of elements in the URL, output the count of elements in ascending order.\n#lang racket\n\n(define (count-pairs arr)\n  (define freq (make-hash))\n  (for ([num arr])\n    (hash-set! freq num (add1 (hash-ref freq num 0))))\n  (define (comb k) (quotient (* k (- k 1)) 2))\n  (define total 0)\n  (for ([count (hash-values freq)])\n    (set! total (+ total (comb count))))\n  total)\n\n(define (main)\n  (define list (map string->number (string-split (read-line))))\n  (define result (count-pairs list)",
    "unclipped": " The order corresponds to the order found in the URL.\n;; input_format\n;; For each corresponding pair of elements in the URL, output the count of elements in ascending order.\n#lang racket\n\n(define (count-pairs arr)\n  (define freq (make-hash))\n  (for ([num arr])\n    (hash-set! freq num (add1 (hash-ref freq num 0))))\n  (define (comb k) (quotient (* k (- k 1)) 2))\n  (define total 0)\n  (for ([count (hash-values freq)])\n    (set! total (+ total (comb count))))\n  total)\n\n(define (main)\n  (define list (map string->number (string-split (read-line))))\n  (define result (count-pairs list))\n  (displayln (string-join (map number->string result) \" \")))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln (number->string result)))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln (number->string results)))\n\n(main)\n  (displayln (string-join (map number->string result) \" \")))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln result))\n  (displayln result))\n\n(main)\n  (displayln (number->string results) result)))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln result))\n  (displayln result))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln result))\n  (displayln result))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln",
    "inputs": "The input consists of several lines. Each line contains space-separated integers representing a sublist.",
    "outputs": "A JSON object where each key is an integer and the value is the number of times it appears across all sublists. Keys and values are separated by colons, and the entire object is enclosed in curly braces. Different key-value pairs are separated by commas followed by a space.",
    "tests": [
      {
        "input": "1 2 3 2\n4 5 6 2\n7 8 9 5",
        "output": "{1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}"
      },
      {
        "input": "1 2 3 4\n5 6 7 8\n9 10 11 12",
        "output": "{1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1}"
      },
      {
        "input": "20 30 40 17\n18 16 14 13\n10 20 30 40",
        "output": "{20: 2, 30: 2, 40: 2, 17: 1, 18: 1, 16: 1, 14: 1, 13: 1, 10: 1}"
      }
    ]
  },
  "solution #4": {
    "solution": "#lang racket\n;; Write a function to remove a specified column from a given nested list.\n;; The input consists of:\n- First line: integer N (number of sublists)\n- Next N lines: each line contains space-separated integers representing a sublist\n- Last line: integer K (the column index to remove)\n;; N lines, each containing space-separated integers of the modified sublist after removing the K-th column.\n;; n+1 (length lst))\n(define n (length (filter (lambda (x) (not (zero? x))) lst))\n(define (remove-kth-column lst k)\n  (if (<= k (length lst))\n      (append (take lst (- k 1))\n      (error \"K is larger than the length of the list\")))\n\n(define (main)\n  (let* ([input (string-split (read-line) \" \")]\n         [n (string->number (take input (- (length input) 1)))])\n    (let ([result (remove-kth-column input)",
    "unclipped": ".\n;; n+1 (length lst))\n(define n (length (filter (lambda (x) (not (zero? x))) lst))\n(define (remove-kth-column lst k)\n  (if (<= k (length lst))\n      (append (take lst (- k 1))\n      (error \"K is larger than the length of the list\")))\n\n(define (main)\n  (let* ([input (string-split (read-line) \" \")]\n         [n (string->number (take input (- (length input) 1)))])\n    (let ([result (remove-kth-column input)])\n      (displayln (string-join result \" \")))))\n\n(main)\n(newline)\n  (let ([n (string->number (remove-kth-column input))])\n    (displayln (string-join n \" \"))))\n\n(main)\n(newline)\n  (displayln (string-join n \" \"))))\n\n(main)\n(newline)\n  (displayln (remove-kth-column input)))\n\n(main)\n(newline)\n  (displayln (string-join (remove-kth-column input) \" \")))\n\n(main)\n(newline)\n  (displayln (string-join result \" \")))\n\n(main)\n(newline)\n  (displayln (remove-kth-column input)))\n\n(main)\n(newline)\n  (displayln (string-join result \" \")))\n\n(main)\n(newline)\n  (displayln result)))\n\n(main)\n(newline)\n  (displayln result)))\n\n(main)\n(newline)\n  (displayln result))\n\n(main)\n(newline)\n  (displayln (string-join (remove-kth-column input) \" \")))\n\n(main)\n(newline)\n  (displayln result)))\n\n(main)\n(newline)\n  (displayln result)))\n\n(main)\n(newline)\n  (displayln result)))\n\n(main)\n(newline)\n  (displayln result))\n\n(main)\n(newline)\n  (displayln result))\n\n(main)\n(newline)\n  (displayln (string-join (remove-kth-column newline) \" \")))\n\n(main)\n(newline)\n  (displayln result)))\n\n(main)\n(newline)\n  (displayln result)))\n\n(main)\n(newline)\n  (displayln result)))\n\n(main)\n(newline)\n  (displayln result)))\n\n(main)\n(newline)\n  (displayln result)))\n\n(main)\n(newline)\n  (displayln result)))\n\n(main)\n(newline)\n  (displayln result)))\n\n(main)\n(newline)\n  (displayln result)))\n\n",
    "inputs": "The input consists of:\n- First line: integer N (number of sublists)\n- Next N lines: each line contains space-separated integers representing a sublist\n- Last line: integer K (the column index to remove)",
    "outputs": "N lines, each containing space-separated integers of the modified sublist after removing the K-th column",
    "tests": [
      {
        "input": "3\n1 2 3\n2 4 5\n1 1 1\n0",
        "output": "2 3\n4 5\n1 1"
      },
      {
        "input": "3\n1 2 3\n-2 4 -5\n1 -1 1\n2",
        "output": "1 2\n-2 4\n1 -1"
      },
      {
        "input": "6\n1 3\n5 7\n1 3\n13 15 17\n5 7\n9 11\n0",
        "output": "3\n7\n3\n15 17\n7\n11"
      }
    ]
  },
  "solution #5": {
    "solution": "#lang racket\n;; Write a function to modify a tuple by replacing the element at a specified index with a list containing a given value. The function returns the new tuple.\n;; The input consists of three lines. The first line is a Python tuple literal representing the original tuple. The second line contains an integer representing the index. The third line contains an integer representing the value to insert into the tuple as a single-element list.\n;; The output is a single line containing the modified tuple as a Python tuple literal.The problem is to find the index of a tuple. Given a list of tuples and an integer, the extra tuple is a subset of the list. If all elements are the same, the problem is the tuple. If all elements are the same, the problem is the tuple. If all elements are the same, the problem is the tuple. Elements are separated by spaces.\n;; input_format\n;; A single integer representing the index. The problem is to find the tuple. If all elements are the same, the problem is the tuple. If all elements are the same, the problem is the tuple. If all elements are the same, the problem is the tuple. If all elements are the same, the problem is the tuple. Elements are separated by spaces.\n;; input_format\n;; A single integer representing the tuple. Elements are separated by spaces, where all elements are the tuple. Elements are separated by spaces.\n#lang racket\n\n(define (element-wise-tuple tuple)\n  (let* ([list (take tuple (sub1 (length tuple)))])\n    (append tuple (list (list list) (list tuple))))\n\n(define (main)\n  (let* ([input (string-split (read-line) \" \")]\n         [tuple (map string->number (take input (sub1 (length input)))))])\n    (displayln (string-join (map number->string (element-wise-tuple tuple)",
    "unclipped": " The problem is to find the index of a tuple. Given a list of tuples and an integer, the extra tuple is a subset of the list. If all elements are the same, the problem is the tuple. If all elements are the same, the problem is the tuple. If all elements are the same, the problem is the tuple. Elements are separated by spaces.\n;; input_format\n;; A single integer representing the index. The problem is to find the tuple. If all elements are the same, the problem is the tuple. If all elements are the same, the problem is the tuple. If all elements are the same, the problem is the tuple. If all elements are the same, the problem is the tuple. Elements are separated by spaces.\n;; input_format\n;; A single integer representing the tuple. Elements are separated by spaces, where all elements are the tuple. Elements are separated by spaces.\n#lang racket\n\n(define (element-wise-tuple tuple)\n  (let* ([list (take tuple (sub1 (length tuple)))])\n    (append tuple (list (list list) (list tuple))))\n\n(define (main)\n  (let* ([input (string-split (read-line) \" \")]\n         [tuple (map string->number (take input (sub1 (length input)))))])\n    (displayln (string-join (map number->string (element-wise-tuple tuple)) \" \"))))\n\n(main)\n    (displayln (string-join (map number->string (element-wise-tuple tuple)) \" \"))))\n\n(main)\n    (displayln (string-join (map number->string (element-wise-tuple tuple)) \" \"))))\n\n(main)\n    (displayln (string-join (map number->string (element-wise-tuple tuple)) \" \"))))\n\n(main)\n    (displayln (string-join (map number->string (element-wise-tuple tuple)) \" \"))))\n\n(main)\n    (displayln (string-join (map number->string (element-wise-tuple tuple)) \" \"))))\n\n(main)\n    (displayln (string-join (map number->string (element-wise-tuple tuple)) \" \"))))\n\n(main)\n    (displayln (string-join (map number->string (element-wise-tuple tuple)) \" \"))))\n\n(main)\n    (displayln (string-join (map number->string (element-wise-tuple tuple)) \" \"))))\n\n(main)\n    (displayln (string-join",
    "inputs": "The input consists of three lines. The first line is a Python tuple literal representing the original tuple. The second line contains an integer representing the index. The third line contains an integer representing the value to insert into the tuple as a single-element list.",
    "outputs": "The output is a single line containing the modified tuple as a Python tuple literal.",
    "tests": [
      {
        "input": "('HELLO', 5, [], True)\n2\n50",
        "output": "('HELLO', 5, [50], True)"
      },
      {
        "input": "('HELLO', 5, [], True)\n2\n100",
        "output": "('HELLO', 5, [100], True)"
      },
      {
        "input": "('HELLO', 5, [], True)\n2\n500",
        "output": "('HELLO', 5, [500], True)"
      }
    ]
  },
  "solution #6": {
    "solution": "#lang racket\n;; Sort a list of subject and mark tuples by the mark in ascending order using a lambda function.\n;; The first line contains an integer N (number of tuples). This is followed by N lines, each containing a subject (possibly with spaces) and an integer mark separated by a space.\n;; N lines, each containing the subject and mark separated by a space, sorted in ascending order of the mark.Each line's elements are separated by a space.\n;; The order corresponds to the order found in the first line.\n;; In Racket, the following line is split into a list of integers.\n;; The order corresponds to the order found in the second line.\n;; in Racket, the following element is the following that matches a string that has an 'a' followed by anything, ending in 'b'.\n;; This is because a regular expression has all elements from the first line that are separated by spaces.\n;; This is because a tuple (using map (lambda (x) (abs (- x y)) (range 1 (add1 b))))))\n\n(define (sort-tuples-by-value input-line)\n  (define tuples (map (lambda (line) (string-split input-line)) (map string->number (take input (sub1 (length input)))) tuples))\n  (define match (lambda (match) (string-join (map number->string (sort (\u03bb (match) (string-join (map number->string (sort (\u03bb (match) (string-join (map number->string (sort (\u03bb (x) (string-join (map number->string (sort x)) \" \"))) tuples)\n  (\u03bb (tuple)\n    (displayln (string-join tuple \" \"))))\n\n(define input (read-line))\n(sort-tuples-by-value input)\n  (let loop ((line input) (total 0))\n    (if (eof-object? line)\n        total\n        (let* ((parts (string-split line))\n               (a (string->number (list-ref t (sub1 a)))))))\n          (if (regexp-match? (\u03bb (tuple) (displayln \" \")) (string-join tuple \" \")))\n      (displayln \" \")))\n    (displayln \" \"))))\n\n(sort-tuples-by-value input)\n    (displayln \" \")))",
    "unclipped": " Each line's elements are separated by a space.\n;; The order corresponds to the order found in the first line.\n;; In Racket, the following line is split into a list of integers.\n;; The order corresponds to the order found in the second line.\n;; in Racket, the following element is the following that matches a string that has an 'a' followed by anything, ending in 'b'.\n;; This is because a regular expression has all elements from the first line that are separated by spaces.\n;; This is because a tuple (using map (lambda (x) (abs (- x y)) (range 1 (add1 b))))))\n\n(define (sort-tuples-by-value input-line)\n  (define tuples (map (lambda (line) (string-split input-line)) (map string->number (take input (sub1 (length input)))) tuples))\n  (define match (lambda (match) (string-join (map number->string (sort (\u03bb (match) (string-join (map number->string (sort (\u03bb (match) (string-join (map number->string (sort (\u03bb (x) (string-join (map number->string (sort x)) \" \"))) tuples)\n  (\u03bb (tuple)\n    (displayln (string-join tuple \" \"))))\n\n(define input (read-line))\n(sort-tuples-by-value input)\n  (let loop ((line input) (total 0))\n    (if (eof-object? line)\n        total\n        (let* ((parts (string-split line))\n               (a (string->number (list-ref t (sub1 a)))))))\n          (if (regexp-match? (\u03bb (tuple) (displayln \" \")) (string-join tuple \" \")))\n      (displayln \" \")))\n    (displayln \" \"))))\n\n(sort-tuples-by-value input)\n    (displayln \" \"))))\n\n(sort-tuples-by-value input)\n    (displayln \" \"))))\n\n(sort-tuples-by-value input)\n    (displayln \" \"))))\n\n(sort-tuples-by-value input)\n    (displayln \" \"))))\n\n(sort-tuples-by-value input)\n    (displayln \" \"))))\n\n(sort-tuples-by-value input)\n    (displayln \" \"))))\n\n(sort-tuples-by-value input)\n    (displayln \" \"))))\n\n(sort-tuples-by-value input)\n    (displayln \" \"))))\n\n(sort-tuples-by-value input)\n    (displayln \" \"))))\n\n",
    "inputs": "The first line contains an integer N (number of tuples). This is followed by N lines, each containing a subject (possibly with spaces) and an integer mark separated by a space.",
    "outputs": "N lines, each containing the subject and mark separated by a space, sorted in ascending order of the mark.",
    "tests": [
      {
        "input": "4\nEnglish 88\nScience 90\nMaths 97\nSocial sciences 82",
        "output": "Social sciences 82\nEnglish 88\nScience 90\nMaths 97"
      },
      {
        "input": "3\nTelugu 49\nHindhi 54\nSocial 33",
        "output": "Social 33\nTelugu 49\nHindhi 54"
      },
      {
        "input": "3\nPhysics 96\nChemistry 97\nBiology 45",
        "output": "Biology 45\nPhysics 96\nChemistry 97"
      }
    ]
  },
  "solution #7": {
    "solution": "#lang racket\n;; Write a function to perform index-wise multiplication of tuple elements in the given two tuples.\n;; The first line contains an integer N, representing the number of tuples in each input. The next N lines contain two integers each, representing the elements of the first tuple's i-th pair. The following N lines contain two integers each, representing the elements of the second tuple's i-th pair.\n;; N lines, each containing two integers separated by a space, representing the index-wise multiplied tuples.Each corresponding elements of the two tuples are separated by a space.\n;; input_format\n;; A single integer representing the corresponding elements of the two tuples.\n#lang racket\n\n(define (read-int-list)\n  (let loop ()\n    (let* ((line (read-line)",
    "unclipped": " Each corresponding elements of the two tuples are separated by a space.\n;; input_format\n;; A single integer representing the corresponding elements of the two tuples.\n#lang racket\n\n(define (read-int-list)\n  (let loop ()\n    (let* ((line (read-line))\n           (if (eof-object? line)\n               (let* ((strs (string-split line))\n               (num (string->number (map string->number strs)))\n               (result (map (lambda (a b) (* a b)) num))\n               (loop (add1 b) result))))))\n\n(define (read-int-list)\n  (let loop ()\n    (if (null? l)\n        l\n        (let ((a (car l))\n              (b (cadr l)))\n          (if (or (null? l) (null? b))\n              a\n              (let b (car l)))\n                (loop (cdr l) b))\n                  (if (null? l)\n                  '()\n                  (let loop (car l) (car l) (car l)))\n                (if (null? l)\n                    l\n                    (loop (cdr l) (car l) (cdr l)))))))\n                  (loop l (cdr l)))))))\n\n(define (main)\n  (let ((result (read-int-list)))\n    (display (string-join result \" \"))))\n\n(main)\n  (let ((l (string->number (read-line))))\n    (display (number->string (read-int-list)))\n    (newline)))\n\n(main)\n    (display (number->string (read-int-list)))\n    (newline)))\n\n(main)\n    (display (number->string (read-int-list)))\n    (newline)))\n\n(main)\n    (display (number->string (read-int-list)))\n    (newline)))\n\n(main)\n    (display (number->string (read-int-list)))\n    (newline)))\n\n(main)\n    (display (number->string (string-join (number->string (read-int-list)) \" \"))))\n\n(main)\n    (displayln result)))\n\n(main)\n    (displayln result)))\n\n(main)\n    (newline)))\n\n(main)\n    (displayln result)))\n\n(main)\n    (displayln result)))\n\n(main)\n    (displayln result)))\n    (newline)))\n\n(main)\n    (displayln result)))\n\n(main)\n    (displayln result)))\n\n(main)\n    (displayln result)))\n\n(main)\n    (displayln result)))\n\n(main)\n    (displayln result)))\n\n(main)\n",
    "inputs": "The first line contains an integer N, representing the number of tuples in each input. The next N lines contain two integers each, representing the elements of the first tuple's i-th pair. The following N lines contain two integers each, representing the elements of the second tuple's i-th pair.",
    "outputs": "N lines, each containing two integers separated by a space, representing the index-wise multiplied tuples.",
    "tests": [
      {
        "input": "4\n1 3\n4 5\n2 9\n1 10\n6 7\n3 9\n1 1\n7 3",
        "output": "6 21\n12 45\n2 9\n7 30"
      },
      {
        "input": "4\n2 4\n5 6\n3 10\n2 11\n7 8\n4 10\n2 2\n8 4",
        "output": "14 32\n20 60\n6 20\n16 44"
      },
      {
        "input": "4\n3 5\n6 7\n4 11\n3 12\n8 9\n5 11\n3 3\n9 5",
        "output": "24 45\n30 77\n12 33\n27 60"
      }
    ]
  },
  "solution #8": {
    "solution": "#lang racket\n;; Given a tuple of integers, return a new tuple where each element is transformed by applying the inversion operation. The inversion operation for an element x is defined as -(x + 1).\n;; A single line containing space-separated integers representing the elements of the input tuple.\n;; A single line containing space-separated integers representing the elements of the output tuple.Elements are separated by spaces.\n;; input_format\n;; A single line containing space-separated integers representing the elements of the output tuple.\n#lang racket\n\n(define (main)\n  (let* ([input (string-split (read-line))]\n         [nums (map string->number input)]\n         [new (apply new nums)])\n    (displayln (string-join (map number->string new) \" \"))))\n\n(main)",
    "unclipped": " Elements are separated by spaces.\n;; input_format\n;; A single line containing space-separated integers representing the elements of the output tuple.\n#lang racket\n\n(define (main)\n  (let* ([input (string-split (read-line))]\n         [nums (map string->number input)]\n         [new (apply new nums)])\n    (displayln (string-join (map number->string new) \" \"))))\n\n(main)\n    (displayln \" \"))))\n\n(main)\n    (displayln (number->string new)))))\n\n(main)\n    (newline)))\n\n(main)\n    (displayln (string-join (map number->string new) \" \"))))\n\n(main)\n    (displayln \" \"))))\n\n(main)\n    (displayln \" \"))))\n\n(main)\n    (newline\n    (displayln (string-join (map number->string new) \" \"))))\n\n(main)\n    (displayln \" \"))))\n\n(main)\n    (displayln \" \"))))\n\n(main)\n    (newline\n    (displayln \" \"))))\n\n(main)\n    (displayln \" \"))))\n\n(main)\n    (newline\n    (displayln (string-join (map number->string (number->string new)) \" \"))))\n\n(main)\n    (displayln \" \"))))\n\n(main)\n    (newline)\n    (displayln \" \"))))\n\n(main)\n    (displayln \" \"))))\n\n(main)\n    (newline)\n    (displayln (string-join (map number->string (number->string new)) \" \"))))\n\n(main)\n    (displayln \" \"))))\n\n(main)\n    (newline)\n    (displayln \" \"))))\n\n(main)\n    (displayln \" \"))))\n\n(main)\n    (newline)\n    (displayln (number->string new))))\n\n(main)\n    (newline)\n    (displayln (string-join (map number->string new) \" \"))))\n\n(main)\n    (displayln \" \"))))\n\n(main)\n    (displayln \" \"))))\n\n(main)\n    (newline)\n    (displayln \" \"))))\n\n(main)\n    (displayln \" \"))))\n\n(main)\n    (displayln \" \"))))\n\n(main)\n    (newline)\n    (displayln (number->string new) \" \"))))\n\n(main)\n    (displayln \" \"))))\n\n(main)\n    (newline)\n    (displayln \" \"))))\n\n(main)\n    (displayln \" \"))))\n\n(main)\n    (newline)\n    (displayln (number->string new)))))\n\n(main)\n    (newline)\n    (displayln (string-",
    "inputs": "A single line containing space-separated integers representing the elements of the input tuple.",
    "outputs": "A single line containing space-separated integers representing the elements of the output tuple.",
    "tests": [
      {
        "input": "7 8 9 1 10 7",
        "output": "-8 -9 -10 -2 -11 -8"
      },
      {
        "input": "2 4 5 6 1 7",
        "output": "-3 -5 -6 -7 -2 -8"
      },
      {
        "input": "8 9 11 14 12 13",
        "output": "-9 -10 -12 -15 -13 -14"
      }
    ]
  },
  "solution #9": {
    "solution": "#lang racket\n;; Sort a list of sublists based on the second element (an integer) of each sublist in ascending order.\n;; The first line contains an integer N (number of sublists). Then N lines follow, each containing a string and an integer separated by a space.\n;; N lines, each containing the string and the integer of the sorted sublist, separated by a space.Each line's elements are separated by spaces.\n;; input_format\n;; Each line contains the string and an integer representing the squared count of sublists, followed by a newline.\n#lang racket\n\n(define (sort-sublists-by-value input-line)\n  (define numbers (map string->number (string-split input-line)))\n  (define (sort numbers <)",
    "unclipped": " Each line's elements are separated by spaces.\n;; input_format\n;; Each line contains the string and an integer representing the squared count of sublists, followed by a newline.\n#lang racket\n\n(define (sort-sublists-by-value input-line)\n  (define numbers (map string->number (string-split input-line)))\n  (define (sort numbers <)\n    (for ([num numbers])\n      (cond\n        [(= num 0) (set! numbers (append numbers (list (list (car numbers))) \n        [(= num 0) (set! numbers (append numbers (list (list (car numbers))) \n        [else (set! sublists (append sublists (list (car numbers)))]\n        [else (set! sublists (append sublists (list (car numbers)))]))\n  (sort sublists <))\n\n(define input (read-line))\n(define sorted-numbers (sort-sublists-by-value input))\n(define output (string-join (map number->string sorted-numbers) \" \"))\n\n(printf \"~a\\n\" output)\n(printf \"~a\\n\" output)\n  (printf \"~a\\n\" output))\n\n(printf \"~a\\n\" output)\n  (printf \"~a\\n\" output))\n\n(define (main)\n  (let* ([n (string->number (read-line))]\n         [sublists (for/list ([i (in-range n)])\n                     (map string->number (string-split sublists))))]\n         [result (sort-sublists-by-value input)])\n    (displayln result)))\n\n(main)\n    (displayln (number->string result))\n    (newline)))\n\n(main)\n    (displayln (string-join (map number->string result) \" \"))))\n\n(main)\n    (displayln result)))\n\n(main)\n    (displayln result)))\n\n(main)\n    (displayln result)))\n\n(main)\n    (displayln result)))\n\n(main)\n    (displayln result)))\n\n(main)\n    (displayln (number->string result))\n    (displayln \"No number found\"))\n    (newline)))\n\n(main)\n    (displayln (string-join (map number->string result) \" \"))))\n\n(main)\n    (displayln result)))\n\n(main)\n    (displayln result)))\n\n(main)\n    (displayln result)))\n\n(main)\n    (displayln \"No number found\"))\n    (newline)))\n\n(main)\n    (displayln (string-join (map number->string result) \" \"))))\n\n(main)\n    (displayln",
    "inputs": "The first line contains an integer N (number of sublists). Then N lines follow, each containing a string and an integer separated by a space.",
    "outputs": "N lines, each containing the string and the integer of the sorted sublist, separated by a space.",
    "tests": [
      {
        "input": "4\na 10\nb 5\nc 20\nd 15",
        "output": "b 5\na 10\nd 15\nc 20"
      },
      {
        "input": "4\n452 10\n256 5\n100 20\n135 15",
        "output": "256 5\n452 10\n135 15\n100 20"
      },
      {
        "input": "4\nrishi 10\nakhil 5\nramya 20\ngaur 15",
        "output": "akhil 5\nrishi 10\ngaur 15\nramya 20"
      }
    ]
  },
  "solution #10": {
    "solution": "#lang racket\n;; Write a Python function to find the GCD of two positive integers.\n;; Two space-separated integers a and b (1 <= a, b <= 10^9).\n;; A single integer: the GCD of a and b.;; b = a * b (gcd a b)",
    "unclipped": "\n;; b = a * b (gcd a b)\n;; a = b * a b))\n;; b = b * a b))\n;; a = a b L)\n;; b = b * a b))\n\n(define (gcd a b)\n  (if (= b 0)\n      a\n      (gcd b (remainder a b))))\n\n(define input (string-split (read-line) \" \"))\n(define a (string->number (car input)))\n(define b (string->number (cadr input)))\n\n(printf \"~a\\n\" (gcd a b))\n(printf \"~a\\n\" (gcd a b))\n  (printf \"a\\n\" (gcd a b)))\n\n(define (main)\n  (let* ([input (read-line)]\n         [parts (string-split input)]\n         [a (string->number (car parts))]\n         [b (string->number (cadr parts))])\n    (printf \"~a\\n\" (gcd a b))))\n\n(main)\n    (printf \"~a\\n\" (gcd a b))))\n\n(main)\n    (printf \"~a\\n\" (gcd a b))))\n\n(main)\n    (printf \"~a\\n\" (gcd a b))))\n\n(main)\n    (printf \"~a\\n\" (gcd a b))))\n\n(main)\n    (printf \"~a\\n\" (gcd a b))))\n\n(main)\n    (printf \"~a\\n\" (gcd a b))))\n\n(main)\n    (printf \"~a\\n\" (gcd a b))))\n\n(main)\n    (printf \"~a\\n\" (gcd a b))))\n\n(main)\n    (printf \"~a\\n\" (gcd a b))))\n\n(main)\n    (printf \"~a\\n\" (gcd a b))))\n\n(main)\n    (printf \"~a\\n\" (gcd a b))))\n\n(main)\n    (printf \"~a\\n\" (gcd a b))))\n\n(main)\n    (printf \"~a\\n\" (gcd a b))))\n\n(main)\n    (printf \"~a\\n\" (gcd a b))))\n\n(main)\n    (printf \"~a\\n\" (gcd a b))))\n\n(main)\n    (printf \"~a\\n\" (gcd a b))))\n\n(main)\n    (printf \"~a\\n\" (gcd a b))))\n\n(main)\n    (printf \"~a\\n\" (gcd a b))))\n\n(main)\n    (printf \"~a\\n\" (gcd a b))))\n\n(main)\n    (printf \"~a\\n\" (gcd a b))))\n\n(main)\n    (printf \"~a\\n\" (gcd a b))))\n\n(main)\n    (printf \"~a\\n\" (gcd a b",
    "inputs": "Two space-separated integers a and b (1 <= a, b <= 10^9).",
    "outputs": "A single integer: the GCD of a and b.",
    "tests": [
      {
        "input": "12 17",
        "output": "1"
      },
      {
        "input": "4 6",
        "output": "2"
      },
      {
        "input": "2 9",
        "output": "1"
      }
    ]
  },
  "solution #11": {
    "solution": "#lang racket\n;; Check if any of the given literal strings are present in the target string. Return 'Matched!' if at least one is found, otherwise 'Not Matched!'.\n;; Two lines. The first line contains space-separated literal strings. The second line contains the target string to search in.\n;; A single line containing either 'Matched!' or 'Not Matched!'.The match is at the beginning of the string\n;; 'Not matched!'.\n;; 'Not matched!'.\n;; The problem is to determine if a given string matches the pattern \"a\" followed by zero or more \"b\"s.\n;; This can be expressed with a regular expression: \"ab*\".\n\n(define (check-string s)\n  (if (regexp-match? #px\"a(b)*\" s)\n      \"Found a match!\"\n      \"Not matched!\"))\n\n(define s (read-line))\n(printf \"~a~n\" (check-string s)",
    "unclipped": " The match is at the beginning of the string\n;; 'Not matched!'.\n;; 'Not matched!'.\n;; The problem is to determine if a given string matches the pattern \"a\" followed by zero or more \"b\"s.\n;; This can be expressed with a regular expression: \"ab*\".\n\n(define (check-string s)\n  (if (regexp-match? #px\"a(b)*\" s)\n      \"Found a match!\"\n      \"Not matched!\"))\n\n(define s (read-line))\n(printf \"~a~n\" (check-string s))\n(printf \"~a\\n\" (check-string s))\n  (printf \"Not matched!\"))\n\n(check-string s)\n  (cond\n    [(regexp-match? #px\"a(b)*\" s) \"Found a match!\"]\n    [else \"Not matched!\"]))\n\n(define s (read-line))\n(printf \"~a\\n\" (check-string s))\n(printf \"~a\\n\" (check-string s))\n))\n  (printf \"Not matched!\"))\n\n(if s)\n      \"Found a match!\"\n      \"Not matched!\"))\n\n(printf \"~a\\n\" (check-string s))\n      \"Not matched!\"))\n(printf \"~a\\n\" (check-string s))\n      \"Not matched!\"))\n(printf \"~a\\n\" (check-string s))\n      \"Not matched!\"))\n(printf \"~a\\n\" (check-string s))\n      \"Not matched!\"))\n(printf \"~a\\n\" (check-string s))\n      \"Not matched!\"))\n(printf \"~a\\n\" (check-string s))\n      \"Not matched!\"))\n(printf \"~a\\n\" (check-string s))\n      \"Not matched!\"))\n(printf \"~a\\n\" (check-string s))\n      \"Not matched!\"))\n(printf \"~a\\n\" (check-string s))\n      \"Not matched!\"))\n(printf \"~a\\n\" (check-string s))\n      \"Not matched!\"))\n(printf \"~a\\n\" (check-string s))\n      \"Not matched!\"))\n(printf \"~a\\n\" (check-string s))\n      \"Not matched!\"))\n(printf \"~a\\n\" (check-string s))\n      \"Not matched!\"))\n(printf \"~a\\n\" (check-string s))\n      \"Not matched!\"))\n(printf \"~a\\n\" (check-string s))\n      \"Not matched!\"))\n(printf \"~a\\n\" (check-string s))\n      \"Not matched!\"))\n(printf \"~a\\n\" (check-string",
    "inputs": "Two lines. The first line contains space-separated literal strings. The second line contains the target string to search in.",
    "outputs": "A single line containing either 'Matched!' or 'Not Matched!'.",
    "tests": [
      {
        "input": "language\npython language",
        "output": "Matched!"
      },
      {
        "input": "program\npython language",
        "output": "Not Matched!"
      },
      {
        "input": "python\nprogramming language",
        "output": "Not Matched!"
      }
    ]
  },
  "solution #12": {
    "solution": "#lang racket\n;; Find the smallest range that includes at least one element from each of the given arrays. The range is represented as a pair (start, end).\n;; The first line contains an integer K denoting the number of arrays. This is followed by K lines, each containing a list of space-separated integers representing the elements of an array in non-decreasing order.\n;; A single line containing two space-separated integers representing the start and end of the smallest possible range.The range is split into a list of integers.\n;; input_format\n;; The output is a single integer, which is the smallest prime divisor of N.\n#lang racket\n\n(define (smallest-prime-divisor n)\n  (define (check-divisor i)\n    (if (> i (sub1 n))\n        (begin\n          (set! (append i (list (list (list i)))\n          (if (<= i (sub1 (length n)))\n              (set! (append i (list (list (list i)))))\n              (check-divisor (+ i 1)))))\n  (check-divisor 2))\n\n(define n (read-line))\n(define arr (map string->number (string-split (read-line))))\n(printf \"~a\\n\" (smallest-prime-divisor n)",
    "unclipped": " The range is split into a list of integers.\n;; input_format\n;; The output is a single integer, which is the smallest prime divisor of N.\n#lang racket\n\n(define (smallest-prime-divisor n)\n  (define (check-divisor i)\n    (if (> i (sub1 n))\n        (begin\n          (set! (append i (list (list (list i)))\n          (if (<= i (sub1 (length n)))\n              (set! (append i (list (list (list i)))))\n              (check-divisor (+ i 1)))))\n  (check-divisor 2))\n\n(define n (read-line))\n(define arr (map string->number (string-split (read-line))))\n(printf \"~a\\n\" (smallest-prime-divisor n))\n(printf \"~a\\n\" (check-divisor start))\n  (check-divisor 2))\n\n(printf \"~a\\n\" (smallest-prime-divisor n))\n  (check-divisor 2))\n\n(printf \"~a\\n\" (smallest-prime-divisor n))\n  (check-divisor 2))\n\n(printf \"~a\\n\" (smallest-prime-divisor n))\n  (check-divisor 2))\n\n(printf \"~a\\n\" (smallest-prime-divisor n))\n  (check-divisor 2))\n\n(printf \"~a\\n\" (smallest-prime-divisor n))\n  (check-divisor 2))\n\n(printf \"~a\\n\" (smallest-prime-divisor n))\n  (check-divisor 2))\n\n(printf \"~a\\n\" (smallest-prime-divisor n))\n  (check-divisor 2))\n\n(printf \"~a\\n\" (smallest-prime-divisor n))\n  (check-divisor 2))\n\n(printf \"~a\\n\" (smallest-prime-divisor n))\n  (check-divisor 2))\n\n(printf \"~a\\n\" (smallest-prime-divisor n))\n  (check-divisor 2))\n\n(printf \"~a\\n\" (smallest-prime-divisor n))\n  (check-divisor 2))\n\n(printf \"~a\\n\" (smallest-prime-divisor n))\n  (check-divisor 2))\n\n(printf \"~a\\n\" (smallest-prime-divisor n))\n  (check-divisor 2))\n\n(printf \"~a\\n\" (smallest-prime-divisor n))\n  (",
    "inputs": "The first line contains an integer K denoting the number of arrays. This is followed by K lines, each containing a list of space-separated integers representing the elements of an array in non-decreasing order.",
    "outputs": "A single line containing two space-separated integers representing the start and end of the smallest possible range.",
    "tests": [
      {
        "input": "4\n3 6 8 10 15\n1 5 12\n4 8 15 16\n2 6",
        "output": "4 6"
      },
      {
        "input": "4\n2 3 4 8 10 15\n1 5 12\n7 8 15 16\n3 6",
        "output": "4 7"
      },
      {
        "input": "4\n4 7 9 11 16\n2 6 13\n5 9 16 17\n3 7",
        "output": "5 7"
      }
    ]
  },
  "solution #13": {
    "solution": "#lang racket\n;; Find the n'th star number using the formula 6*n*(n-1) + 1.\n;; A single integer n.\n;; A single integer representing the n'th star number.The Jacobst number is calculated as b^2 - 4ac. Return a number if there is a perfect square, or the string 'None' otherwise. The Jacobst number is calculated as b^2 - 1ac. The Jacobst number is calculated as b^2 - 4ac. The Jacobst number is calculated as b^2 - 1ac. The Jacobst number is calculated as b^2 - 4ac. Return a number if there is a perfect square, or the string 'None' otherwise.\n;; input_format\n;; A single integer representing the n-tohst number.\n#lang racket\n\n(define (calculate-n-1) (* 2 n))\n  (if (<= n 0)\n      0\n      (let loop ((a b) (a b) (result 1))\n        (if (= a b) result\n            (loop (- a b) (- a b) (* 2 a)))))))\n\n(define (main)\n  (let ((n (string->number (read-line))))\n    (display (calculate-n-1)",
    "unclipped": " The Jacobst number is calculated as b^2 - 4ac. Return a number if there is a perfect square, or the string 'None' otherwise. The Jacobst number is calculated as b^2 - 1ac. The Jacobst number is calculated as b^2 - 4ac. The Jacobst number is calculated as b^2 - 1ac. The Jacobst number is calculated as b^2 - 4ac. Return a number if there is a perfect square, or the string 'None' otherwise.\n;; input_format\n;; A single integer representing the n-tohst number.\n#lang racket\n\n(define (calculate-n-1) (* 2 n))\n  (if (<= n 0)\n      0\n      (let loop ((a b) (a b) (result 1))\n        (if (= a b) result\n            (loop (- a b) (- a b) (* 2 a)))))))\n\n(define (main)\n  (let ((n (string->number (read-line))))\n    (display (calculate-n-1) n))\n    (newline)))\n\n(main)\n(main)\n    (display (number->string n))\n    (newline)))\n\n(main)\n    (newline)))\n\n(main)\n    (display (calculate-n-1) n))\n    (newline)))\n\n(main)\n    (newline)))\n\n(main)\n    (display (number->string n))\n    (newline)))\n\n(main)\n    (newline (display \"None\"))\n    (newline)))\n\n(main)\n    (newline (display \"None\"))\n    (newline)))\n\n(main)\n    (newline (display \"None\"))\n    (newline)))\n\n(main)\n    (newline (display \"None\"))\n    (newline)))\n\n(main)\n    (display (calculate-n-1) n))\n    (newline)))\n\n(main)\n    (newline (display \"None\"))\n    (newline)))\n\n(main)\n    (display (number->string n))\n    (newline)))\n\n(main)\n    (newline (display \"None\"))\n    (newline)))\n\n(main)\n    (newline (display \"None\"))\n    (newline)))\n\n(main)\n    (newline (display \"None\"))\n    (newline)))\n\n(main)\n    (newline (display \"None\"))\n    (newline)))\n\n(main)\n    (newline))\n    (display \"None\"))\n    (newline)))\n\n(main)\n    (newline (display \"None\"))\n    (newline)))\n\n(main)\n    (newline (display \"None\"))\n    (newline)))\n\n(main)\n    (newline (",
    "inputs": "A single integer n.",
    "outputs": "A single integer representing the n'th star number.",
    "tests": [
      {
        "input": "3",
        "output": "37"
      },
      {
        "input": "4",
        "output": "73"
      },
      {
        "input": "5",
        "output": "121"
      }
    ]
  },
  "solution #14": {
    "solution": "#lang racket\n;; Check if a triangle is equilateral given the lengths of its sides.\n;; Three integers a, b, c separated by spaces.\n;; True or Falseare equal (indicating no profit and no loss).\n;; input_format\n;; A single line containing 'True' if the triangle is equal, 'False' otherwise.\n#lang racket\n\n(define (main)\n  (let* ([input (string-split (read-line) \" \")]\n         [parts (string-split input)]\n         [a (string->number (car parts))]\n         [b (string->number (cadr parts))])\n    (printf \"~a\\n\" (if (= a b) \"True\" \"False\"))))\n\n(main)",
    "unclipped": " are equal (indicating no profit and no loss).\n;; input_format\n;; A single line containing 'True' if the triangle is equal, 'False' otherwise.\n#lang racket\n\n(define (main)\n  (let* ([input (string-split (read-line) \" \")]\n         [parts (string-split input)]\n         [a (string->number (car parts))]\n         [b (string->number (cadr parts))])\n    (printf \"~a\\n\" (if (= a b) \"True\" \"False\"))))\n\n(main)\n    (printf \"~a\\n\" (if (= b 0) \"True\" \"False\"))))\n\n(main)\n    (printf \"~a\\n\" (if (= a b) \"True\" \"False\"))))\n\n(main)\n    (printf \"~a\\n\" (if (= b 0) \"True\" \"False\"))))\n\n(main)\n    (printf \"~a\\n\" (if (= a b) \"True\" \"False\"))))\n\n(main)\n    (printf \"~a\\n\" (if (= a b) \"True\" \"False\"))))\n\n(main)\n    (printf \"~a\\n\" (if (= b 0) \"True\" \"False\"))))\n\n(main)\n    (printf \"~a\\n\" (if (= a b) \"True\" \"False\"))))\n\n(main)\n    (printf \"~a\\n\" (if (= a b) \"True\" \"False\"))))\n\n(main)\n    (printf \"~a\\n\" (if (= a b) \"True\" \"False\"))))\n\n(main)\n    (printf \"~a\\n\" (if (= a b) \"True\" \"False\"))))\n\n(main)\n    (printf \"~a\\n\" (if (= b 0) \"True\" \"False\"))))\n\n(main)\n    (printf \"~a\\n\" (if (= a b) \"True\" \"False\"))))\n\n(main)\n    (printf \"~a\\n\" (if (= a b) \"True\" \"False\"))))\n\n(main)\n    (printf \"~a\\n\" (if (= a b) \"True\" \"False\"))))\n\n(main)\n    (printf \"~a\\n\" (if (= a b) \"True\" \"False\"))))\n\n(main)\n    (printf \"~a\\n\" (if (= a b) \"True\" \"False\"))))\n\n(main)\n    (printf \"~a\\n\" (if (= a b) \"True\" \"False\"))))\n\n(main)\n    (printf \"~a\\n\" (if (=",
    "inputs": "Three integers a, b, c separated by spaces.",
    "outputs": "True or False",
    "tests": [
      {
        "input": "6 8 12",
        "output": "False"
      },
      {
        "input": "6 6 12",
        "output": "False"
      },
      {
        "input": "6 6 6",
        "output": "True"
      }
    ]
  },
  "solution #15": {
    "solution": "#lang racket\n;; Given two lists of tuples, remove all tuples from the first list that are present in the second list and return the resulting list.\n;; Two lines. The first line is the first list of tuples, and the second line is the second list. Each list is represented as a Python list of tuples, with tuples in parentheses and elements separated by commas. Tuples in the list are separated by commas and a space.\n;; A single line containing the resulting list of tuples in the same format as the input.The output is a single line containing space-separated integers representing the resulting list after removing all tuples from the list.\n;; input_format\n;; A single line containing space-separated integers representing the resulting list after removing all tuples from the list.\n#lang racket\n\n(define (remove-tuples-by-list input)\n  (define elements (map string->number (string-split input)))\n  (define tuples (map (lambda (tuple) (list-ref tuple x)) tuples))\n  (define result (remove-tuples-by-list tuple)",
    "unclipped": " The output is a single line containing space-separated integers representing the resulting list after removing all tuples from the list.\n;; input_format\n;; A single line containing space-separated integers representing the resulting list after removing all tuples from the list.\n#lang racket\n\n(define (remove-tuples-by-list input)\n  (define elements (map string->number (string-split input)))\n  (define tuples (map (lambda (tuple) (list-ref tuple x)) tuples))\n  (define result (remove-tuples-by-list tuple))\n  (string-join (map number->string result) \" \"))\n\n(define input (read-line))\n(define output (remove-tuples-by-list input))\n(printf \"~a\\n\" output)\n  (string-join (map number->string output) \" \"))\n\n(printf \"~a\\n\" output)\n  (string-join (map number->string output) \" \"))\n\n(define output (remove-tuples-by-list input))\n(printf \"~a\\n\" output)\n  (string-join (map number->string output) \" \"))\n\n(printf \"~a\\n\" output)\n  (string-join (map number->string output) \" \"))\n\n(printf \"~a\\n\" output)\n  (string-join result \" \"))\n\n(printf \"~a\\n\" output)\n  (string-join (map number->string result) \" \"))\n\n(printf \"~a\\n\" output)\n  (string-join (map number->string result) \" \"))\n\n(printf \"~a\\n\" output)\n  (string-join (map number->string result) \" \"))\n\n(printf \"~a\\n\" output)\n  (string-join (map number->string result) \" \"))\n\n(printf \"~a\\n\" output)\n  (string-join (map number->string result) \" \"))\n\n(printf \" \"))\n  (string-join (map number->string result) \" \"))\n\n(printf \" \"))\n  (string-join (map number->string result) \" \"))\n\n(printf \" \"))\n  (string-join (map number->string result) \" \"))\n\n(printf \" \"))\n  (number->string result))\n\n(define input (read-line))\n(define output (remove-tuples-by-list input))\n(printf \"~a\\n\" output)\n  (string-join output \" \"))\n\n(printf \"~a\\n\" output)\n  (string-join (map number->string output) \" \"))\n\n(printf \" \"))\n  (string",
    "inputs": "Two lines. The first line is the first list of tuples, and the second line is the second list. Each list is represented as a Python list of tuples, with tuples in parentheses and elements separated by commas. Tuples in the list are separated by commas and a space.",
    "outputs": "A single line containing the resulting list of tuples in the same format as the input.",
    "tests": [
      {
        "input": "[('Hello', 'dude'), ('How', 'are'), ('you', '?')]\n[('Hello', 'dude'), ('How', 'are')]",
        "output": "[('you', '?')]"
      },
      {
        "input": "[('Part', 'of'), ('the', 'journey'), ('is ', 'end')]\n[('Journey', 'the'), ('is', 'end')]",
        "output": "[('Part', 'of'), ('the', 'journey'), ('is ', 'end')]"
      },
      {
        "input": "[('Its', 'been'), ('a', 'long'), ('day', 'without')]\n[('a', 'long'), ('my', 'friend')]",
        "output": "[('Its', 'been'), ('day', 'without')]"
      }
    ]
  },
  "solution #16": {
    "solution": "#lang racket\n;; Find all index positions of the minimum values in a given list.\n;; A single line containing space-separated integers representing the list.\n;; A single line containing space-separated integers representing the indices of the minimum values in the order they appear.It are not in the input list.\n;; input_format\n;; A single integer representing the index of the min value in the input list.\n#lang racket\n\n(define (find-min-index arr)\n  (define len (length arr))\n  (define min-index 0)\n  (define result -1)\n\n  (for ([i (in-range len)])\n    (when (< (list-ref arr i) min-index)\n      (set! min-index (number->string result))))\n  min-index)\n\n(define input (string-split (read-line)))\n(define nums (map string->number input))\n(printf \"~a\\n\" (find-min-index nums)",
    "unclipped": " It are not in the input list.\n;; input_format\n;; A single integer representing the index of the min value in the input list.\n#lang racket\n\n(define (find-min-index arr)\n  (define len (length arr))\n  (define min-index 0)\n  (define result -1)\n\n  (for ([i (in-range len)])\n    (when (< (list-ref arr i) min-index)\n      (set! min-index (number->string result))))\n  min-index)\n\n(define input (string-split (read-line)))\n(define nums (map string->number input))\n(printf \"~a\\n\" (find-min-index nums))\n(printf \"~a\\n\" (string-join (map number->string min-index) \" \"))\n))\n  (printf \"None\\n\"))\n\n(find-min-index)\n  (define min-index (for/fold ([min-index 0]) ([i (in-range len)])\n    (when (< (number? (list-ref arr i))\n      (set! min-index (number->string min-index)))\n    min-index))\n\n(printf \"~a\\n\" (find-min-index arr))\n    min-index))\n\n(printf \"~a\\n\" (string-join (map number->string min-index) \" \"))\n    min-index))\n\n(printf \"~a\\n\" (find-min-index arr))\n    min-index))\n\n(printf \"~a\\n\" (find-min-index arr))\n    min-index))\n\n(printf \"~a\\n\" (string-join (map number->string min-index) \" \"))\n    min-index))\n\n(printf \"~a\\n\" (find-min-index arr))\n    min-index))\n\n(printf \"~a\\n\" (find-min-index arr))\n    min-index))\n\n(printf \"~a\\n\" (find-min-index arr))\n    min-index))\n\n(printf \"~a\\n\" (find-min-index arr))\n    min-index))\n\n(printf \"~a\\n\" (find-min-index arr))\n    min-index))\n\n(printf \"~a\\n\" (find-min-index arr))\n    min-index))\n\n(printf \"~a\\n\" (find-min-index arr))\n    min-index))\n\n(printf \"~a\\n\" (find-min-index arr))\n    min-index))\n\n(printf \"~a\\n\" (find-min-index arr))\n    min-index))\n\n(printf \"~a\\n\" (find-min-index arr))\n    min-index))\n\n(printf \"~a\\n\" (find-min-index arr))\n    min-index))\n\n(printf \"~a\\n\" (find-min-index arr))\n   ",
    "inputs": "A single line containing space-separated integers representing the list.",
    "outputs": "A single line containing space-separated integers representing the indices of the minimum values in the order they appear.",
    "tests": [
      {
        "input": "12 33 23 10 67 89 45 667 23 12 11 10 54",
        "output": "3 11"
      },
      {
        "input": "1 2 2 2 4 4 4 5 5 5 5",
        "output": "0"
      },
      {
        "input": "2 1 5 6 8 3 4 9 10 11 8 12",
        "output": "1"
      }
    ]
  },
  "solution #17": {
    "solution": "#lang racket\n;; Find the smallest negative number (most negative) from the given list of integers.\n;; A single line containing space-separated integers representing the list.\n;; A single integer, the smallest negative number in the list.Output on a single line.\n;; input_format\n;; A single integer, the smallest positive number in a list of integers.\n#lang racket\n\n(define (smallest-negatives lst)\n  (cond\n    [(empty? lst) 0]\n    [(= (length lst) 1) 0]\n    [else\n     (let loop ((lst lst))\n       (cond\n         [(empty? l) 0]\n         [(<= (car l) (cadr l)) (cons (car l) (smallest-negatives l)",
    "unclipped": " Output on a single line.\n;; input_format\n;; A single integer, the smallest positive number in a list of integers.\n#lang racket\n\n(define (smallest-negatives lst)\n  (cond\n    [(empty? lst) 0]\n    [(= (length lst) 1) 0]\n    [else\n     (let loop ((lst lst))\n       (cond\n         [(empty? l) 0]\n         [(<= (car l) (cadr l)) (cons (car l) (smallest-negatives l))]\n         [else (loop (cdr l)]))]))\n\n(define input (string-split (read-line)))\n(define numbers (map string->number input))\n(define result (smallest-negatives numbers))\n(printf \"~a\\n\" (string-join (map number->string result) \" \"))\n))\n(printf \"~a\\n\" result)\n  (loop (cdr l) result))\n\n(printf \"~a\\n\" result)\n  (loop (cdr l) result))\n\n(printf \"~a\\n\" (string-join (map number->string result) \" \"))\n  (loop l))\n\n(printf \"~a\\n\" result)\n  (displayln (string-join (map number->string result) \" \")))\n\n(newline)\n  (displayln \"No result\")))\n\n(newline)\n  (displayln \"No result\")))\n\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline",
    "inputs": "A single line containing space-separated integers representing the list.",
    "outputs": "A single integer, the smallest negative number in the list.",
    "tests": [
      {
        "input": "1 2 3 -4 -6",
        "output": "-6"
      },
      {
        "input": "1 2 3 -8 -9",
        "output": "-9"
      },
      {
        "input": "1 2 3 4 -1",
        "output": "-1"
      }
    ]
  },
  "solution #18": {
    "solution": "#lang racket\n;; Check if all values in a dictionary are the same as a given value.\n;; The first line contains the value V to check. The second line contains N, the number of key-value pairs. The next N lines each contain a key (which may include spaces) and an integer value separated by a space.\n;; Output \"True\" if all dictionary values are equal to V, otherwise output \"False\".Each line's elements are separated by a space.\n;; input_format\n;; A single line containing 'True' if all lines are equal, 'False' otherwise.\n#lang racket\n\n(define (check-equality-pairs arr)\n  (define freq (make-hash))\n  (for ([num arr])\n    (hash-set! freq num (add1 (hash-ref freq num 0))))\n  (define (equal? freq (hash-ref freq num 1))\n  (define (check-pairs f)",
    "unclipped": " Each line's elements are separated by a space.\n;; input_format\n;; A single line containing 'True' if all lines are equal, 'False' otherwise.\n#lang racket\n\n(define (check-equality-pairs arr)\n  (define freq (make-hash))\n  (for ([num arr])\n    (hash-set! freq num (add1 (hash-ref freq num 0))))\n  (define (equal? freq (hash-ref freq num 1))\n  (define (check-pairs f)\n    (cond\n      [(= f (hash-ref freq num 0)) #t]\n      [(= (hash-ref freq p) 0) #t]\n      [(= (hash-ref freq p) 0) #t]\n      [(< (hash-ref freq p) 0) #f]\n      [else (hash-ref freq p)]))\n  (check-equality-pairs arr))\n\n(define (main)\n  (define input (read-line))\n  (define values (map string->number (string-split input)))\n  (printf \"~a\\n\" (check-equality-pairs input)))\n\n(main)\n  (printf \"~a\\n\" (check-equality pairs input)))\n\n(main)\n  (printf \"~a\\n\" (check-equality pairs input)))\n\n(main)\n  (printf \"~a\\n\" (check-equality pairs input)))\n\n(main)\n  (printf \"~a\\n\" (check-equality pairs input)))\n\n(main)\n  (printf \"~a\\n\" (check-equality pairs input)))\n\n(main)\n  (printf \"~a\\n\" (check-equality pairs input)))\n\n(main)\n  (printf \"~a\\n\" (check-equality pairs input)))\n\n(main)\n  (printf \"~a\\n\" (check-equality pairs input)))\n\n(main)\n  (printf \"~a\\n\" (check-equality pairs input)))\n\n(main)\n  (printf \"~a\\n\" (check-equality pairs input)))\n\n(main)\n  (printf \"~a\\n\" (check-equality pairs input)))\n\n(main)\n  (printf \"~a\\n\" (check-equality pairs input)))\n\n(main)\n  (printf \"~a\\n\" (check-equality pairs input)))\n\n(main)\n  (printf \"~a\\n\" (check-equality pairs input)))\n\n(main)\n  (printf \"~a\\n\" (check-equality pairs input)))\n\n(main)\n  (printf \"~a\\n\" (check-equality pairs input)))\n\n(main",
    "inputs": "The first line contains the value V to check. The second line contains N, the number of key-value pairs. The next N lines each contain a key (which may include spaces) and an integer value separated by a space.",
    "outputs": "Output \"True\" if all dictionary values are equal to V, otherwise output \"False\".",
    "tests": [
      {
        "input": "10\n4\nCierra Vega 12\nAlden Cantrell 12\nKierra Gentry 12\nPierre Cox 12",
        "output": "False"
      },
      {
        "input": "12\n4\nCierra Vega 12\nAlden Cantrell 12\nKierra Gentry 12\nPierre Cox 12",
        "output": "True"
      },
      {
        "input": "5\n4\nCierra Vega 12\nAlden Cantrell 12\nKierra Gentry 12\nPierre Cox 12",
        "output": "False"
      }
    ]
  },
  "solution #19": {
    "solution": "#lang racket\n;; Perform element-wise exponentiation of two tuples. Each element in the first tuple is raised to the power of the corresponding element in the second tuple.\n;; Two lines containing space-separated integers. The first line represents the first tuple, the second line represents the second tuple.\n;; A single line containing space-separated integers representing the resulting tuple after exponentiation.Each element of the second tuple are separated by spaces.\n;; input_format\n;; A single line containing space-separated integers representing the result tuple.\n#lang racket\n\n(define (main)\n  (let* ([input (read-line)]\n         [parts (string-split input)]\n         [a (string->number (car parts))]\n         [b (string->number (cadr parts))])\n    (displayln (string-join (map number->string (move b b)) \" \"))))\n\n(main)",
    "unclipped": " Each element of the second tuple are separated by spaces.\n;; input_format\n;; A single line containing space-separated integers representing the result tuple.\n#lang racket\n\n(define (main)\n  (let* ([input (read-line)]\n         [parts (string-split input)]\n         [a (string->number (car parts))]\n         [b (string->number (cadr parts))])\n    (displayln (string-join (map number->string (move b b)) \" \"))))\n\n(main)\n  (displayln (string-join (map number->string (move b b)) \" \")))\n\n(main)\n  (displayln (string-join (map number->string (move b b)) \" \")))\n\n(main)\n  (displayln (string-join (map number->string (move b b)) \" \")))\n\n(main)\n  (displayln (string-join (map number->string (move b b)) \" \")))\n\n(main)\n  (displayln (string-join (map number->string (move b b)) \" \")))\n\n(main)\n  (displayln (string-join (map number->string (move b b)) \" \")))\n\n(main)\n  (displayln \" \")))\n\n(main)\n  (displayln (string-join (map number->string (move b b)) \" \")))\n\n(main)\n  (displayln (string-join (map number->string (move b b)) \" \")))\n\n(main)\n  (displayln \" \")))\n\n(main)\n  (displayln \" \")))\n\n(main)\n  (displayln (string-join (map number->string (move b 1)) \" \")))\n\n(main)\n  (displayln -1)))\n\n(main)\n  (displayln -1))\n\n(main)\n  (displayln -1)))\n\n(main)\n  (displayln -1)))\n\n(main)\n  (displayln -1)))\n\n(main)\n  (displayln -1)))\n\n(main)\n  (displayln -1)\n  (displayln -1)))\n\n(main)\n  (displayln -1)))\n\n(main)\n  (displayln -1)))\n\n(main)\n  (displayln -1)))\n\n(main)\n  (displayln -1)))\n\n(main)\n  (displayln -1)))\n\n(main)\n  (displayln -1)))\n\n(main)\n  (newline)\n  (displayln -1)))\n\n(main)\n  (displayln -1)))\n\n(main)\n  (displayln -1)))\n\n(main)\n  (newline)\n  (displayln -",
    "inputs": "Two lines containing space-separated integers. The first line represents the first tuple, the second line represents the second tuple.",
    "outputs": "A single line containing space-separated integers representing the resulting tuple after exponentiation.",
    "tests": [
      {
        "input": "10 4 5 6\n5 6 7 5",
        "output": "100000 4096 78125 7776"
      },
      {
        "input": "11 5 6 7\n6 7 8 6",
        "output": "1771561 78125 1679616 117649"
      },
      {
        "input": "12 6 7 8\n7 8 9 7",
        "output": "35831808 1679616 40353607 2097152"
      }
    ]
  },
  "solution #20": {
    "solution": "#lang racket\n;; Count the number of squares in a rectangle of size m x n. A rectangle contains squares of various sizes, and the task is to compute the total count.\n;; A single line containing two space-separated integers m and n, representing the dimensions of the rectangle.\n;; A single integer representing the total number of squares in the rectangle.The total count is calculated as b^2 - 4ac. Return a tuple containing both integers m and n, where m is larger than n.\n;; input_format\n;; The output is a single integer, which is the total count of squares in the rectangle.\n#lang racket\n\n(define (count-squares m n)\n  (let* ([total 0])\n    (let ([count (count (lambda (x) (if (> x n) 3 2)) 0)",
    "unclipped": " The total count is calculated as b^2 - 4ac. Return a tuple containing both integers m and n, where m is larger than n.\n;; input_format\n;; The output is a single integer, which is the total count of squares in the rectangle.\n#lang racket\n\n(define (count-squares m n)\n  (let* ([total 0])\n    (let ([count (count (lambda (x) (if (> x n) 3 2)) 0)))\n        (let ([count (count (count (quotient (- (* 2 x) 1)) 2))))\n    (if (> count n)\n        (let ([total (+ total (count-squares m n))))\n          total)))\n\n(define (main)\n  (let ([input (read-line)])\n    (let ([values (map string->number (string-split input \" \"))])\n      (m (car values))\n      (n (cadr values)))))\n\n(main)\n  (displayln (count-squares m n)))\n\n(main)\n  (displayln (displayln 0)))\n\n(main)\n  (displayln (count-squares m n)))\n\n(main)\n  (displayln (number->string (count-squares m n)))\n\n(main)\n  (displayln (number->string (count-squares m n)))\n\n(main)\n  (displayln (number->string (count-squares m n)))\n\n(main)\n  (displayln (number->string (count-squares m n)))\n\n(main)\n  (displayln (number->string (count-squares m n)))\n\n(main)\n  (displayln (number->string (count-squares m n)))\n\n(main)\n  (displayln (number->string (count-squares m n)))\n\n(main)\n  (displayln total))\n  (displayln total))\n\n(main)\n  (let ([m (car m)])\n    (displayln total)))\n\n(main)\n    (let ([n (cadr m)])\n      (let ([m (caddr l)])\n        (displayln total))))\n\n(main)\n    (displayln total)))\n\n(main)\n    (displayln total)))\n\n(main)\n    (displayln total)))\n\n(main)\n    (displayln total)))\n\n(main)\n    (displayln total)))\n\n(main)\n    (displayln total)))\n\n(main)\n    (displayln total))\n    (newline)))\n\n(main)\n    (displayln total))\n    (newline)))\n\n(main)\n    (displayln total)))\n\n(main)\n    (displayln total)))\n\n(main",
    "inputs": "A single line containing two space-separated integers m and n, representing the dimensions of the rectangle.",
    "outputs": "A single integer representing the total number of squares in the rectangle.",
    "tests": [
      {
        "input": "4 3",
        "output": "20"
      },
      {
        "input": "1 2",
        "output": "2"
      },
      {
        "input": "2 2",
        "output": "5"
      }
    ]
  },
  "solution #21": {
    "solution": "#lang racket\n;; Convert a given string to lowercase.\n;; A single line containing the string to be converted.\n;; A single line containing the lowercase version of the input string.The output is a single line containing the converted snake case string.\n;; input_format\n;; A single line containing the converted snake case string.\n#lang racket\n\n(define (camel-to-snake s)\n  (let* ([trimmed (substring s 1 (string-length s))] ; Remove all characters except letters and numbers\n         [ch (make-vector (+ (string-length s) 1) 0)])\n    (vector-set! sieve 0 0)\n    (for ([ch (in-string s)])\n      (cond\n        [(char-alph (string-ref s ch)) (string-append s (string ch)))]\n        [(char-numeric? (string-ref s (add1 ch)) (string-append s (string ch)))]\n        [else (string-append s (string-join (vector-ref sieve) ch))]))]))\n\n(define s (read-line))\n(printf \"~a\\n\" (camel-to-snake s)",
    "unclipped": " The output is a single line containing the converted snake case string.\n;; input_format\n;; A single line containing the converted snake case string.\n#lang racket\n\n(define (camel-to-snake s)\n  (let* ([trimmed (substring s 1 (string-length s))] ; Remove all characters except letters and numbers\n         [ch (make-vector (+ (string-length s) 1) 0)])\n    (vector-set! sieve 0 0)\n    (for ([ch (in-string s)])\n      (cond\n        [(char-alph (string-ref s ch)) (string-append s (string ch)))]\n        [(char-numeric? (string-ref s (add1 ch)) (string-append s (string ch)))]\n        [else (string-append s (string-join (vector-ref sieve) ch))]))]))\n\n(define s (read-line))\n(printf \"~a\\n\" (camel-to-snake s))\n(printf \"~a\\n\" s)\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))",
    "inputs": "A single line containing the string to be converted.",
    "outputs": "A single line containing the lowercase version of the input string.",
    "tests": [
      {
        "input": "InValid",
        "output": "invalid"
      },
      {
        "input": "TruE",
        "output": "true"
      },
      {
        "input": "SenTenCE",
        "output": "sentence"
      }
    ]
  },
  "solution #22": {
    "solution": "#lang racket\n;; Find the first maximum length even word in a given string. An even word is a word whose length is even. If multiple words have the same maximum even length, return the first occurrence. If no even-length words exist, return -1.\n;; A single line containing a string of words separated by spaces.\n;; A single line containing the first maximum length even word, or -1 if none exist.The order corresponds to the (n+1)-th most expensive word (n+1)-th most expensive word (2-1)-th most expensive word (3-1))))))\n\n(define (find-first-occurrence s)\n  (define (helper chars)\n    (cond\n      [(empty? chars) -1]\n      [(= (car chars) (helper (cdr chars)) -1]\n      [else (let ((word (car chars)))\n        (if (null? word)\n            (let ((min-len (car (sort (helper (cdr words) min-len))))\n              (if min-len\n                  (let loop ((current-len min-len)\n                    (if (null? current-len)\n                    min-len\n                    (let ((current-len (car min-len)))\n                (if (< current-len min-len)\n                    (loop (cdr min-len current-len)\n                    (if min min-len current-len)\n                      (loop (cdr min-len current-len)\n                      (loop (cdr min-len current-len)))))))))\n\n(define (main)\n  (let ((input (string-split (read-line))))\n    (let ((s (car input)))\n      (let ((result (find-first-occurrence s)",
    "unclipped": " The order corresponds to the (n+1)-th most expensive word (n+1)-th most expensive word (2-1)-th most expensive word (3-1))))))\n\n(define (find-first-occurrence s)\n  (define (helper chars)\n    (cond\n      [(empty? chars) -1]\n      [(= (car chars) (helper (cdr chars)) -1]\n      [else (let ((word (car chars)))\n        (if (null? word)\n            (let ((min-len (car (sort (helper (cdr words) min-len))))\n              (if min-len\n                  (let loop ((current-len min-len)\n                    (if (null? current-len)\n                    min-len\n                    (let ((current-len (car min-len)))\n                (if (< current-len min-len)\n                    (loop (cdr min-len current-len)\n                    (if min min-len current-len)\n                      (loop (cdr min-len current-len)\n                      (loop (cdr min-len current-len)))))))))\n\n(define (main)\n  (let ((input (string-split (read-line))))\n    (let ((s (car input)))\n      (let ((result (find-first-occurrence s)))\n        (display (if result \"True\" result)\n            (display \"False\"))\n          (display \"False\")))))\n\n(main)\n          (display \"False\")))\n            (newline)))\n\n(main)\n          (display \"False\")))\n            (display \"False\")))))\n\n(main)\n            (display \"False\")))))\n\n(main)\n            (newline\n          (display \"False\")))\n            (newline)))\n\n(main)\n          (display \"False\")))\n            (display \"False\")))))\n\n(main)\n            (newline\n          (display \"False\")))\n            (newline)))\n\n(main)\n            (newline\n            (display \"True\")))\n          (display \"False\")))\n            (newline)))\n\n(main)\n            (display \"True\")))\n          (display \"False\")))\n            (newline)))))\n\n(main)\n          (display \"True\")))\n            (display \"False\")))\n          (display \"False\"))))\n\n(main)\n          (display \"False\")))\n            (newline)))\n\n(main)\n            (display \"True\")))\n          (display \"False\")))))\n\n(main)\n          (display \"False\")))\n            (newline)))))\n\n(main)\n            (newline\n          (display \"False\")))\n            (display \"False\")))\n          (newline)))))\n\n(main)\n            (display \"False\")))\n          (newline)))))\n\n(main)\n            (newline (",
    "inputs": "A single line containing a string of words separated by spaces.",
    "outputs": "A single line containing the first maximum length even word, or -1 if none exist.",
    "tests": [
      {
        "input": "python language",
        "output": "language"
      },
      {
        "input": "maximum even length",
        "output": "length"
      },
      {
        "input": "eve",
        "output": "-1"
      }
    ]
  },
  "solution #23": {
    "solution": "#lang racket\n;; Given a list of tuples and an integer k, find all tuples where every element is divisible by k.\n;; The input consists of multiple lines. The first line contains an integer n denoting the number of tuples. This is followed by n lines, each containing space-separated integers representing the elements of a tuple. The last line contains the integer k.\n;; The output is a single line containing the filtered list of tuples in the format [(a, b, c), ...], where each tuple's elements are separated by commas and spaces.Each tuple's elements are separated by spaces.\n;; input_format\n;; Each line's elements are separated by spaces.\n#lang racket\n\n;; Read all lines from input\n(define input (port->lines (current-input-port)))\n\n;; Process each line\n(for ([line input])\n  (define parts (string-split line))\n  (define k (string->number (last parts)))\n  (define tuples (for/list ([line (take input (- (length input) 1))])\n                   (let* ([parts (string-split line)]\n                        [a (string->number (car parts))]\n                        [b (string->number (cadr parts)))\n                     (string-join (map number->string (append a b)) \" \")))\n                     (number->string (car parts)))))))\n\n;; Process each tuple\n(for ([tuple tuples])\n  (define (process-input)\n    (let* ([a (car tuple)]\n           [b (cadr tuple)]\n           [result (append result (list (list a b c)))])\n      (displayln (string-join (map number->string result) \" \")))))\n\n;; Main loop to read input and print output\n(define (main)\n  (let* ([k (string->number (cadr parts))])\n    (displayln (string-join (map number->string (process-input)",
    "unclipped": " Each tuple's elements are separated by spaces.\n;; input_format\n;; Each line's elements are separated by spaces.\n#lang racket\n\n;; Read all lines from input\n(define input (port->lines (current-input-port)))\n\n;; Process each line\n(for ([line input])\n  (define parts (string-split line))\n  (define k (string->number (last parts)))\n  (define tuples (for/list ([line (take input (- (length input) 1))])\n                   (let* ([parts (string-split line)]\n                        [a (string->number (car parts))]\n                        [b (string->number (cadr parts)))\n                     (string-join (map number->string (append a b)) \" \")))\n                     (number->string (car parts)))))))\n\n;; Process each tuple\n(for ([tuple tuples])\n  (define (process-input)\n    (let* ([a (car tuple)]\n           [b (cadr tuple)]\n           [result (append result (list (list a b c)))])\n      (displayln (string-join (map number->string result) \" \")))))\n\n;; Main loop to read input and print output\n(define (main)\n  (let* ([k (string->number (cadr parts))])\n    (displayln (string-join (map number->string (process-input)) \" \"))))\n\n(main)\n  (displayln \" \")))\n\n(main)\n  (displayln (string-join (map number->string (process-input)) \" \"))))\n\n(main)\n  (displayln (number->string (main)))\n  (displayln \" \")))\n\n(main)\n  (displayln \" \")))\n\n(main)\n  (displayln \" \")))\n\n(main)\n  (displayln (number->string (process-input)))\n  (displayln \" \")))\n\n(main)\n  (displayln \" \")))\n\n(main)\n  (displayln \" \")))\n\n(main)\n  (displayln \" \")))\n\n(main)\n  (let ([result (process-input)])\n    (displayln (number->string result))))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln \" \")))\n\n(main)\n  (let ([line (read-line)])\n    (displayln (number->string (main) \" \"))))\n\n(main)\n  (displayln (number->string (main) \" \")))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln result))\n\n(main)\n  (displayln (number->string (",
    "inputs": "The input consists of multiple lines. The first line contains an integer n denoting the number of tuples. This is followed by n lines, each containing space-separated integers representing the elements of a tuple. The last line contains the integer k.",
    "outputs": "The output is a single line containing the filtered list of tuples in the format [(a, b, c), ...], where each tuple's elements are separated by commas and spaces.",
    "tests": [
      {
        "input": "3\n6 24 12\n7 9 6\n12 18 21\n6",
        "output": "[(6, 24, 12)]"
      },
      {
        "input": "3\n5 25 30\n4 2 3\n7 8 9\n5",
        "output": "[(5, 25, 30)]"
      },
      {
        "input": "3\n7 9 16\n8 16 4\n19 17 18\n4",
        "output": "[(8, 16, 4)]"
      }
    ]
  },
  "solution #24": {
    "solution": "#lang racket\n;; Compute the sum of digits of each valid integer in a list. The list contains elements that are either integers or strings. Only process elements that are integers (ignoring their sign), sum their digits, and return the total sum.\n;; The first line contains an integer N, the number of elements. Then N lines follow, each containing a single element as a string, which can be a valid integer (e.g., '123', '-45') or another string.\n;; A single integer, the sum of the digits of all valid integers in the input list.Count the number of ways to make change for a given amount using the first m denominations from a list of coins. Each coin can be used multiple times.\n;; input_format\n;; A single integer representing the number of ways to form the target amount using the given denominations.\n#lang racket\n\n(define (count-digits-of-list m n)\n  (let ((dp (make-vector (+ n 1) 0)))\n    (vector-set! dp 0 1) ; One way to make amount 0\n    (for ([coin (take coins m)])\n      (for ([i (in-range coin (+ n 1))])\n        (vector-set! dp i (+ (vector-ref dp i) (vector-ref dp (- i coin))))))\n    (vector-ref dp n)))\n\n(define (main)\n  (let* ([coins (map string->number (string-split (read-line)))]\n         [m-n (map string->number (string-split (read-line)))]\n         [m (car m-n)]\n         [n (cadr m-n)])\n    (printf \"~a\\n\" (count-digits-of-list m n)",
    "unclipped": " Count the number of ways to make change for a given amount using the first m denominations from a list of coins. Each coin can be used multiple times.\n;; input_format\n;; A single integer representing the number of ways to form the target amount using the given denominations.\n#lang racket\n\n(define (count-digits-of-list m n)\n  (let ((dp (make-vector (+ n 1) 0)))\n    (vector-set! dp 0 1) ; One way to make amount 0\n    (for ([coin (take coins m)])\n      (for ([i (in-range coin (+ n 1))])\n        (vector-set! dp i (+ (vector-ref dp i) (vector-ref dp (- i coin))))))\n    (vector-ref dp n)))\n\n(define (main)\n  (let* ([coins (map string->number (string-split (read-line)))]\n         [m-n (map string->number (string-split (read-line)))]\n         [m (car m-n)]\n         [n (cadr m-n)])\n    (printf \"~a\\n\" (count-digits-of-list m n))))\n\n(main)\n(main)\n  (let ([n (string->number (read-line))])\n    (printf \"~a\\n\" (count-digits-of-list n))))\n\n(main)\n(main)\n  (let ([m (string->number (string-split (read-line)))]\n         [n (string->number (string-split (read-line)))]\n         [sum (for/fold ([sum 0]) ([i (in-range coin (+ n 1))])\n    (printf \"~a\\n\" (count-digits-of-list i n))))\n\n(main)\n(main)\n  (let ([m (string->number (string-split (read-line)))]\n         [n (string->number (string-split (read-line)))]\n         [sum (for/fold ([sum 0]) ([i (in-range coin (+ n 1))])\n    (printf \"~a\\n\" (count-digits-of-list i n))))\n\n(main)\n  (let ([m (string->number (string-split (read-line)))]\n         [n (string->number (string-split (read-line))])\n    (displayln (count-digits-of-list n))))\n\n(main)\n(main)\n  (let ([m (string->number (string-split (read-line))])\n    (displayln (count-digits-of-list m n))))\n\n(main",
    "inputs": "The first line contains an integer N, the number of elements. Then N lines follow, each containing a single element as a string, which can be a valid integer (e.g., '123', '-45') or another string.",
    "outputs": "A single integer, the sum of the digits of all valid integers in the input list.",
    "tests": [
      {
        "input": "3\n10\n2\n56",
        "output": "14"
      },
      {
        "input": "7\n10\n20\n4\n5\nb\n70\na",
        "output": "19"
      },
      {
        "input": "5\n10\n20\n-4\n5\n-70",
        "output": "19"
      }
    ]
  },
  "solution #25": {
    "solution": "#lang racket\n;; Find the nth term of an arithmetic progression given the first term a, term number n, and common difference d.\n;; Three integers a, n, d separated by spaces.\n;; A single integer representing the nth term of the arithmetic progression.The Jacobsthal sequence is defined by J(0) = 0, J(1) = 1, and J(n) = n-1) + 2*J(n-1) + 2*J(n-2) for n \u2265 2.\n;; input_format\n;; The nth Jacobsthal sequence as an integer\n#lang racket\n\n(define (jacobsthal n)\n  (cond\n    [(= n 0) 0]\n    [(= n 1) 1]\n    [else\n     (let* ([a (first n)]\n            [b (second n)]\n            [a (third n)]\n            [b (second n)]\n            [diff (abs (- a b))])\n                  (if (= b 0)\n                  b\n                  (+ a b) (if (= b 0) b c))))))\n\n(define (main)\n  (let ([n (string->number (read-line))])\n    (displayln (jacobsthal n)",
    "unclipped": " The Jacobsthal sequence is defined by J(0) = 0, J(1) = 1, and J(n) = n-1) + 2*J(n-1) + 2*J(n-2) for n \u2265 2.\n;; input_format\n;; The nth Jacobsthal sequence as an integer\n#lang racket\n\n(define (jacobsthal n)\n  (cond\n    [(= n 0) 0]\n    [(= n 1) 1]\n    [else\n     (let* ([a (first n)]\n            [b (second n)]\n            [a (third n)]\n            [b (second n)]\n            [diff (abs (- a b))])\n                  (if (= b 0)\n                  b\n                  (+ a b) (if (= b 0) b c))))))\n\n(define (main)\n  (let ([n (string->number (read-line))])\n    (displayln (jacobsthal n))))\n\n(main)\n    (newline)))\n\n(main)\n    (displayln (jacobsthal n))))\n\n(main)\n    (newline\n    (displayln (jacobsthal n))))\n\n(main)\n    (newline\n    (displayln (jacobsthal n))))\n\n(main)\n    (displayln (jacobsthal n))))\n\n(main)\n    (displayln (jacobsthal n))))\n\n(main)\n    (displayln (jacobsthal n))))\n\n(main)\n    (newline)))\n\n(main)\n    (displayln (jacobsthal n))))\n\n(main)\n    (displayln (jacobsthal n))))\n\n(main)\n    (displayln (jacobsthal n))))\n\n(main)\n    (displayln (jacobsthal n))))\n\n(main)\n    (displayln (jacobsthal n))))\n\n(main)\n    (displayln (displayln \"No oddsthal n))))\n\n(main)\n    (displayln (jacobsthal n))))\n\n(main)\n    (displayln (displayln \"No oddsthal n))))\n\n(main)\n    (displayln (jacobsthal n))))\n\n(main)\n    (displayln (displayln \"No oddsthal n))))\n\n(main)\n    (displayln (jacobsthal n))))\n\n(main)\n    (displayln (displayln \"No oddsthal n))))\n\n(main)\n    (displayln (jacobsthal n))))\n\n(main)\n    (displayln (displayln \"No odd",
    "inputs": "Three integers a, n, d separated by spaces.",
    "outputs": "A single integer representing the nth term of the arithmetic progression.",
    "tests": [
      {
        "input": "1 5 2",
        "output": "9"
      },
      {
        "input": "2 6 4",
        "output": "22"
      },
      {
        "input": "1 4 5",
        "output": "16"
      }
    ]
  },
  "solution #26": {
    "solution": "#lang racket\n;; Find the ratio of zeroes in an array of integers. The ratio is calculated as the number of zeroes divided by the total number of elements, rounded to two decimal places.\n;; A single line containing space-separated integers representing the array.\n;; A single line containing a floating-point number with exactly two decimal places.The array is split into a list of integers.\n;; input_format\n;; A single integer representing the fixed point number.\n#lang racket\n\n(define (find-fixed-point arr)\n  (define n (length arr))\n  (for/fold ([result '()]) ([i (in-range n)])\n    (if (= (list-ref arr i) n)\n        i\n        result)))\n\n(define (main)\n  (let* ([n (string->number (read-line))]\n         [arr (map string->number (string-split (read-line)))])\n    (displayln (find-fixed-point arr)",
    "unclipped": " The array is split into a list of integers.\n;; input_format\n;; A single integer representing the fixed point number.\n#lang racket\n\n(define (find-fixed-point arr)\n  (define n (length arr))\n  (for/fold ([result '()]) ([i (in-range n)])\n    (if (= (list-ref arr i) n)\n        i\n        result)))\n\n(define (main)\n  (let* ([n (string->number (read-line))]\n         [arr (map string->number (string-split (read-line)))])\n    (displayln (find-fixed-point arr))))\n\n(main)\n    (displayln (string-join (map number->string (find-fixed-point arr)) \" \"))))\n\n(main)\n    (displayln -1)\n    (displayln -1))))\n\n(main)\n    (newline)\n    (displayln -1)\n    (displayln -1))))\n\n(main)\n    (newline)))\n\n(main)\n    (displayln (find-fixed-point arr))))\n\n(main)\n    (newline)))\n\n(main)\n    (displayln -1)\n    (displayln -1)\n    (displayln -1)\n    (newline)))\n\n(main)\n    (displayln -1)\n    (displayln -1)\n    (displayln -1)\n    (newline)))\n\n(main)\n    (displayln (string-join (map number->string (find-fixed-point arr)) \" \"))))\n\n(main)\n    (displayln -1)\n    (displayln -1)\n    (displayln -1))))\n\n(main)\n    (newline)\n    (displayln -1)\n    (displayln -1)\n    (displayln -1))))\n\n(main)\n    (newline)\n    (displayln -1)\n    (displayln -1))))\n\n(main)\n    (newline)\n    (displayln -1)\n    (displayln -1))))\n\n(main)\n    (newline)\n    (displayln -1)\n    (displayln -1))))\n\n(main)\n    (displayln -1)\n    (displayln -1)))\n\n(main)\n    (newline)\n    (displayln -1)\n    (displayln -1))))\n\n(main)\n    (displayln -1)\n    (newline)))\n\n(main)\n    (displayln -1)\n    (displayln -1)\n    (displayln -1))))\n\n(main)\n    (newline)\n    (displayln -1)\n    (displayln -1))))\n\n(main)\n    (newline)\n    (displayln -1)\n   ",
    "inputs": "A single line containing space-separated integers representing the array.",
    "outputs": "A single line containing a floating-point number with exactly two decimal places.",
    "tests": [
      {
        "input": "0 1 2 -1 -5 6 0 -3 -2 3 4 6 8",
        "output": "0.15"
      },
      {
        "input": "2 1 2 -1 -5 6 4 -3 -2 3 4 6 8",
        "output": "0.00"
      },
      {
        "input": "2 4 -6 -9 11 -12 14 -5 17",
        "output": "0.00"
      }
    ]
  },
  "solution #27": {
    "solution": "#lang racket\n;; Find the sum of the largest and smallest value in a given array of integers.\n;; A single line containing space-separated integers.\n;; An integer representing the sum of the largest and smallest values in the array.Each element is either an integer or the smallest values of the array.\n;; input_format\n;; The sum of the array elements is on a single line.\n#lang racket\n\n(define (sum-array)\n  (let* ([input (string-split (read-line))]\n         [numbers (map string->number input)]\n         [sum (apply + numbers)])\n    (displayln (string-join (map number->string sum) \" \"))))\n\n(sum-array)",
    "unclipped": " Each element is either an integer or the smallest values of the array.\n;; input_format\n;; The sum of the array elements is on a single line.\n#lang racket\n\n(define (sum-array)\n  (let* ([input (string-split (read-line))]\n         [numbers (map string->number input)]\n         [sum (apply + numbers)])\n    (displayln (string-join (map number->string sum) \" \"))))\n\n(sum-array)\n    sum))\n\n(sum-array)\n    (displayln (string-join (map number->string sum) \" \"))))\n\n(sum-array)\n    (displayln (string-join (map number->string sum) \" \"))))\n\n(sum-array)\n    (displayln (string-join (map number->string sum) \" \"))))\n\n(sum-array)\n    (displayln (string-join (map number->string sum) \" \"))))\n\n(sum-array)\n    (displayln (string-join (map number->string sum) \" \"))))\n\n(sum-array)\n    (displayln (string-join (map number->string sum) \" \"))))\n\n(sum-array)\n    (displayln \" \"))))\n\n(sum-array)\n    (displayln \" \"))))\n\n(sum-array)\n    (displayln (string-join (map number->string sum) \" \"))))\n\n(sum-array)\n    (displayln \" \"))))\n\n(sum-array)\n    (displayln \" \"))))\n\n(sum-array)\n    (displayln \" \"))))\n\n(sum-array)\n    (displayln \" \"))))\n\n(sum-array)\n    (displayln \" \"))))\n\n(sum-array)\n    (displayln (string-join (map number->string sum) \" \"))))\n\n(sum-array)\n    (displayln \" \"))))\n\n(sum-array)\n    (displayln \" \"))))\n\n(sum-array)\n    (displayln \" \"))))\n\n(sum-array)\n    (displayln \" \"))))\n\n(sum-array)\n    (displayln \" \"))))\n\n(sum-array)\n    (displayln \" \"))))\n\n(sum-array)\n    (displayln \" \"))))\n\n(sum-array)\n    (displayln \" \"))))\n\n(sum-array)\n    (displayln \" \"))))\n\n(sum-array)\n    (displayln \" \"))))\n\n(sum-array)\n    (displayln \" \"))))\n\n(sum-array)\n    (displayln \" \"))))\n\n(sum-array)\n    (displayln \" \"))))\n\n(sum-array)\n    (displayln \" \"))))\n\n(sum-array)\n    (displayln \" \"))))\n\n(sum-array)\n    (displayln \" \"))))\n\n(sum-array)\n    (displayln",
    "inputs": "A single line containing space-separated integers.",
    "outputs": "An integer representing the sum of the largest and smallest values in the array.",
    "tests": [
      {
        "input": "1 2 3",
        "output": "4"
      },
      {
        "input": "-1 2 3 4",
        "output": "3"
      },
      {
        "input": "2 3 6",
        "output": "8"
      }
    ]
  },
  "solution #28": {
    "solution": "#lang racket\n;; Find the sum of a geometric progression series given the first term (a), number of terms (n), and common ratio (r). The sum is calculated using the formula: a*(r**n - 1)//(r - 1) when r != 1.\n;; Three integers a, n, r separated by spaces on a single line.\n;; A single integer representing the sum of the geometric progression.A, b, l+1 is a classic dynamic programming problem for a large triangle (i.e., three numbers are equal, 4, and r+1 is the most optimal solution for a large triangle (sum, i.e., when i < 3)\n;; input_format\n;; A single integer representing the sum of the triangle, printed on a single line.\n#lang racket\n\n(define (sum-uc Triangle n)",
    "unclipped": " A, b, l+1 is a classic dynamic programming problem for a large triangle (i.e., three numbers are equal, 4, and r+1 is the most optimal solution for a large triangle (sum, i.e., when i < 3)\n;; input_format\n;; A single integer representing the sum of the triangle, printed on a single line.\n#lang racket\n\n(define (sum-uc Triangle n)\n  (let* ([sum 0])\n    (if (> n 0)\n        sum\n        (let ([i (in-range 2 (add1 n))])\n          (when (> i n)\n            (set! sum (+ sum i)))\n          (set! sum (+ sum i))))\n        sum)))\n\n(define n (string->number (read-line)))\n(printf \"~a\\n\" (sum-uc Triangle n))\n(printf \"~a\\n\" (sum-uc Triangle n))\n        n)))\n\n(printf \"~a\\n\" (sum-uc Triangle n))\n        (sum-uc Triangle n)))\n    (sum-uc Triangle n)))\n\n(printf \"~a\\n\" (sum-uc Triangle n))\n        (sum-uc Triangle n))))\n    (sum-uc Triangle n)))\n\n(printf \"~a\\n\" (sum-uc Triangle n))\n        (sum-uc Triangle n))))\n    (sum-uc Triangle n)))\n\n(printf \"~a\\n\" (sum-uc Triangle n))\n(printf \"~a\\n\" (sum-uc Triangle n))\n        (sum-uc Triangle n))))\n    (sum-uc Triangle n)))\n\n(printf \"~a\\n\" (sum-uc Triangle n))\n        (sum-uc Triangle n))))\n    (sum-uc Triangle n)))\n\n(printf \"~a\\n\" (sum-uc Triangle n))\n(printf \"~a\\n\" (sum-uc Triangle n))\n        (sum-uc Triangle n))))\n    (sum-uc Triangle n)))\n\n(printf \"~a\\n\" (sum-uc Triangle n))\n        (sum-uc Triangle n))))\n    (sum-uc Triangle n)))\n\n(printf \"~a\\n\" (sum-uc Triangle n))\n        (sum-uc Triangle n))))\n    (sum-uc Triangle n)))\n\n(printf \"~a\\n\" (sum-uc Triangle n))\n        (sum-uc Triangle n))))\n    (sum-uc Triangle n)))\n\n(printf \"~a\\n\" (sum-uc Triangle n))\n(printf \"~a\\n\" (sum-uc",
    "inputs": "Three integers a, n, r separated by spaces on a single line.",
    "outputs": "A single integer representing the sum of the geometric progression.",
    "tests": [
      {
        "input": "1 5 2",
        "output": "31"
      },
      {
        "input": "1 5 4",
        "output": "341"
      },
      {
        "input": "2 6 3",
        "output": "728"
      }
    ]
  },
  "solution #29": {
    "solution": "#lang racket\n;; Write a Python function to find the sum of all elements that are repeated in a given array. An element is considered repeated if it appears at least twice. For each such element, all its occurrences are included in the sum.\n;; Each input consists of two lines: the first line contains an integer n (the length of the array), and the second line contains n integers representing the elements of the array.\n;; The output is a single integer representing the sum of all repeated elements as described.A's are separated by spaces.\n;; input_format\n;; A single integer representing the sum of all elements in the array.\n#lang racket\n\n(define (sum-uc-first-occ n arr)\n  (define (helper lst)\n    (cond\n      [(empty? lst) 0]\n      [(= (length lst) 1) 0]\n      [else (let* ((first (take lst 2))\n             (reversed-first (reverse first)))\n        (if (null? rest)\n            l\n            (let* ((first (car rest))\n                  (rest (cdr rest)))\n              (cond\n                [(= rest first) (set! l (+ l 1))]\n                [(= first rest) (set! rest (cdr rest))))]\n                [else (set! l (+ l 1))]))\n            (helper l))))))\n  (helper l))\n\n(define (main)\n  (let* ((input (string-split (read-line)))\n         (nums (map string->number input)))\n    (printf \"~a\\n\" (sum-uc-first-occ nums)",
    "unclipped": " A's are separated by spaces.\n;; input_format\n;; A single integer representing the sum of all elements in the array.\n#lang racket\n\n(define (sum-uc-first-occ n arr)\n  (define (helper lst)\n    (cond\n      [(empty? lst) 0]\n      [(= (length lst) 1) 0]\n      [else (let* ((first (take lst 2))\n             (reversed-first (reverse first)))\n        (if (null? rest)\n            l\n            (let* ((first (car rest))\n                  (rest (cdr rest)))\n              (cond\n                [(= rest first) (set! l (+ l 1))]\n                [(= first rest) (set! rest (cdr rest))))]\n                [else (set! l (+ l 1))]))\n            (helper l))))))\n  (helper l))\n\n(define (main)\n  (let* ((input (string-split (read-line)))\n         (nums (map string->number input)))\n    (printf \"~a\\n\" (sum-uc-first-occ nums))))\n\n(main)\n(main)\n  (displayln (sum-uc-first-occ nums)))\n\n(main)\n  (displayln (sum-uc-first-occ nums)))\n\n(main)\n  (displayln (sum-uc-first-occ nums)))\n\n(main)\n  (displayln (sum-uc-first-occ nums)))\n\n(main)\n  (displayln (sum-uc-first-occ nums)))\n\n(main)\n  (displayln (sum-uc-first-occ nums)))\n\n(main)\n  (displayln (sum-uc-first-occ nums)))\n\n(main)\n  (displayln (sum-uc-first-occ nums)))\n\n(main)\n  (displayln (sum-uc-first-occ nums)))\n\n(main)\n  (displayln (sum-uc-first-occ nums)))\n\n(main)\n  (displayln (sum-uc-first-occ nums)))\n\n(main)\n  (displayln (sum-uc-first-occ nums)))\n\n(main)\n  (displayln (sum-uc-first-occ nums)))\n\n(main)\n  (displayln (sum-uc-first-occ nums)))\n\n(main)\n  (displayln (sum-uc-first-occ nums)))\n\n(main)\n  (displayln (sum-uc-first-occ nums)))\n\n(main)\n  (displayln (sum-uc-first-occ nums)))\n\n(main)\n  (displayln (sum-uc-first-occ nums)))\n\n(main)\n ",
    "inputs": "Each input consists of two lines: the first line contains an integer n (the length of the array), and the second line contains n integers representing the elements of the array.",
    "outputs": "The output is a single integer representing the sum of all repeated elements as described.",
    "tests": [
      {
        "input": "8\n1 2 3 1 1 4 5 6",
        "output": "3"
      },
      {
        "input": "5\n1 2 3 1 1",
        "output": "3"
      },
      {
        "input": "3\n1 1 2",
        "output": "2"
      }
    ]
  },
  "solution #30": {
    "solution": "#lang racket\n;; Write a function to remove uppercase substrings from a given string by using regex.\n;; A single line containing the input string.\n;; A single line containing the resulting string after removing all uppercase substrings.The input string is split into a list of strings and one number of characters in the string.\n;; input_format\n;; A single line containing the list of strings with all uppercase substrs removed.\n#lang racket\n\n(define (remove-uppercase-substrs input-string)\n  (regexp-replace* #px\"[A-Z0-9]\" input-string))\n\n(define input (read-line))\n(define output (remove-uppercase-substrs input)",
    "unclipped": " The input string is split into a list of strings and one number of characters in the string.\n;; input_format\n;; A single line containing the list of strings with all uppercase substrs removed.\n#lang racket\n\n(define (remove-uppercase-substrs input-string)\n  (regexp-replace* #px\"[A-Z0-9]\" input-string))\n\n(define input (read-line))\n(define output (remove-uppercase-substrs input))\n(printf \"~a\\n\" output)\n  (printf \"~a\\n\" output))\n\n(printf \"~a\\n\" output)\n  (string-replace input-string \" \" \"\"))\n\n(define input (read-line))\n(define output (remove-uppercase-substrs input))\n(printf \"~a\\n\" output)\n  (printf \"~a\\n\" output))\n\n(printf \"~a\\n\" output)\n  (string-replace input-string \" \" \"\"))\n\n(printf \"~a\\n\" output)\n  (printf \"~a\\n\" output))\n\n(printf \"~a\\n\" output)\n  (printf \" \"))\n  (printf \" \"))\n\n(printf \"~a\\n\" output)\n  (printf \" \"))\n\n(printf \"~a\\n\" output)\n  (printf \" \"))\n\n(printf \"~a\\n\" output)\n  (printf \" \"))\n\n(printf \"~a\\n\" output)\n  (printf \" \"))\n\n(printf \"~a\\n\" output)\n  (printf \" \"))\n\n(printf \"~a\\n\" output)\n  (printf \" \"))\n\n(printf \"~a\\n\" output)\n  (printf \" \"))\n\n(printf \"~a\\n\" output)\n  (printf \" \"))\n\n(printf \"~a\\n\" output)\n  (printf \" \"))\n\n(printf \"~a\\n\" output)\n  (printf \" \"))\n\n(printf \"~a\\n\" output)\n  (printf \" \"))\n\n(printf \"~a\\n\" output)\n  (printf \" \"))\n\n(printf \"~a\\n\" output)\n  (printf \" \"))\n\n(printf \"~a\\n\" output)\n  (printf \" \"))\n\n(printf \"~a\\n\" output)\n  (printf \" \"))\n\n(printf \"~a\\n\" output)\n  (printf \" \"))\n\n(printf \"~a\\n\" output)\n  (printf \" \"))\n\n(printf \"~a\\n\" output)\n  (printf \" \"))\n\n(printf \"~a\\n\" output)\n  (printf \" \"))\n\n(printf \"~a\\n\" output)\n  (printf \" \"))\n\n(printf \"~a\\n\" output)\n",
    "inputs": "A single line containing the input string.",
    "outputs": "A single line containing the resulting string after removing all uppercase substrings.",
    "tests": [
      {
        "input": "cAstyoUrFavoRitETVshoWs",
        "output": "cstyoravoitshos"
      },
      {
        "input": "wAtchTheinTernEtrAdIo",
        "output": "wtchheinerntrdo"
      },
      {
        "input": "VoicESeaRchAndreComMendaTionS",
        "output": "oiceachndreomendaion"
      }
    ]
  },
  "solution #31": {
    "solution": "#lang racket\n;; Split a list into n sublists, where each sublist contains every nth element starting from the corresponding position. For example, given a list and an integer n, the first sublist contains elements at indices 0, 0+n, 0+2n, etc., the second sublist starts at index 1, and so on until the nth sublist.\n;; The first line contains the elements of the list separated by spaces. The second line contains a single integer n.\n;; n lines, each containing the elements of a sublist separated by spaces. The sublists are ordered from the first to the nth.Each element is separated by spaces.\n;; input_format\n;; Each element of the sublists from the first to the n-th power.\n#lang racket\n\n(define (find-first-occ list n)\n  (cond\n    [(< n 0) 0]\n    [(= n 1) 1]\n    [else\n     (let loop ((i 2) (a 1) (b 1))\n       (if (= i n)\n           b\n           (loop (+ i 1) b (+ a b))))]))\n\n(define n (read-line))\n(define result (find-first-occ (map string->number (string-split (read-line))))",
    "unclipped": " Each element is separated by spaces.\n;; input_format\n;; Each element of the sublists from the first to the n-th power.\n#lang racket\n\n(define (find-first-occ list n)\n  (cond\n    [(< n 0) 0]\n    [(= n 1) 1]\n    [else\n     (let loop ((i 2) (a 1) (b 1))\n       (if (= i n)\n           b\n           (loop (+ i 1) b (+ a b))))]))\n\n(define n (read-line))\n(define result (find-first-occ (map string->number (string-split (read-line))))\n(printf \"~a\\n\" (string-join (map number->string result) \" \"))\n))\n(printf \"~a\\n\" result)\n  (loop b 1))\n\n(find-first-occ n\n  (cond\n    [(= n 0) 0]\n    [(= n 1) 1]\n    [else\n     (let loop ((i 2) (b 1))\n       (if (> i n)\n           b\n           (loop (+ i 1) b (+ a b))))]))\n\n(printf \"~a\\n\" (find-first-occ list n))\n  (loop start 0))\n\n(printf \"~a\\n\" (find-first-occ list n))\n  (loop b 1))\n\n(printf \"~a\\n\" (find-first-occ list n))\n  (loop start 1))\n\n(printf \"~a\\n\" (find-first-occ list n))\n  (loop b 1))\n\n(printf \"~a\\n\" (find-first-occ list n))\n  (loop b 1))\n\n(printf \"~a\\n\" (find-first-occ list n))\n  (loop start 1))\n\n(printf \"~a\\n\" (find-first-occ list n))\n  (loop b 1))\n\n(printf \"~a\\n\" (find-first-occ list n))\n  (loop start 1))\n\n(printf \"~a\\n\" (find-first-occ list n))\n  (loop b 1))\n\n(printf \"~a\\n\" (find-first-occ list n))\n  (loop start 1))\n\n(printf \"~a\\n\" (find-first-occ list n))\n  (loop b 1))\n\n(printf \"~a\\n\" (find-first-occ list n))\n  (loop start 1))\n\n(occ n)\n ",
    "inputs": "The first line contains the elements of the list separated by spaces. The second line contains a single integer n.",
    "outputs": "n lines, each containing the elements of a sublist separated by spaces. The sublists are ordered from the first to the nth.",
    "tests": [
      {
        "input": "a b c d e f g h i j k l m n\n3",
        "output": "a d g j m\nb e h k n\nc f i l"
      },
      {
        "input": "1 2 3 4 5 6 7 8 9 10 11 12 13 14\n3",
        "output": "1 4 7 10 13\n2 5 8 11 14\n3 6 9 12"
      },
      {
        "input": "python java C C++ DBMS SQL\n2",
        "output": "python C DBMS\njava C++ SQL"
      }
    ]
  },
  "solution #32": {
    "solution": "#lang racket\n;; Calculate the distance between two points using latitude and longitude.\n;; Four space-separated floating-point numbers representing lat1 lon1 lat2 lon2.\n;; A single floating-point number representing the distance in meters, formatted with as many decimal digits as required for exact precision.The order corresponds to the order found in the URL.\n;; input_format\n;; A single integer representing the length of the URL.\n#lang racket\n\n(define (main)\n  (let* ([input (read-line)]\n         [parts (string-split input)]\n         [a (string->number (car parts))]\n         [b (string->number (cadr parts))])\n    (displayln (caddr parts) (caddr parts) (fourth (caddr parts) (caddr parts))))))\n\n(main)",
    "unclipped": " The order corresponds to the order found in the URL.\n;; input_format\n;; A single integer representing the length of the URL.\n#lang racket\n\n(define (main)\n  (let* ([input (read-line)]\n         [parts (string-split input)]\n         [a (string->number (car parts))]\n         [b (string->number (cadr parts))])\n    (displayln (caddr parts) (caddr parts) (fourth (caddr parts) (caddr parts))))))\n\n(main)\n(main)\n  (displayln (caddr parts)))\n  (newline)))\n\n(main)\n  (displayln (caddr parts)))\n\n(main)\n  (displayln (caddr parts)))\n\n(main)\n  (newline\n    (displayln (caddr parts))))\n\n(main)\n  (displayln (caddr parts)))\n\n(main)\n  (newline\n    (displayln (caddr parts))))\n\n(main)\n  (displayln (caddr parts)))\n\n(main)\n  (newline\n    (displayln (caddr parts))\n    (newline)))\n\n(main)\n    (displayln (caddr parts))))\n\n(main)\n    (newline\n    (displayln (caddr parts))))\n\n(main)\n    (newline\n    (displayln (caddr parts))))\n\n(main)\n    (newline\n    (displayln (caddr parts)))))\n\n(main)\n    (newline\n    (displayln (caddr parts))\n    (newline)))\n\n(main)\n    (displayln (caddr parts))\n    (newline)))\n\n(main)\n    (displayln (caddr parts))))\n\n(main)\n    (newline\n    (displayln (caddr parts))))\n\n(main)\n    (newline\n    (displayln (caddr parts))))\n\n(main)\n    (newline\n    (displayln (caddr parts))))\n\n(main)\n    (newline\n    (displayln (caddr parts))))\n\n(main)\n    (newline\n    (displayln (caddr parts))))\n\n(main)\n    (displayln (caddr parts))))\n\n(main)\n    (newline\n    (displayln (caddr parts))))\n\n(main)\n    (newline\n    (displayln (caddr parts))))\n\n(main)\n    (newline\n    (displayln (caddr parts))))\n\n(main)\n    (newline\n    (displayln (caddr parts))))\n\n(main)\n    (newline\n    (displayln (caddr parts))))\n\n(main)\n    (displayln (caddr parts))))\n\n(main)\n    (newline\n    (displayln (c",
    "inputs": "Four space-separated floating-point numbers representing lat1 lon1 lat2 lon2.",
    "outputs": "A single floating-point number representing the distance in meters, formatted with as many decimal digits as required for exact precision.",
    "tests": [
      {
        "input": "23.5 67.5 25.5 69.5",
        "output": "12179.372041317429"
      },
      {
        "input": "10.5 20.5 30.5 40.5",
        "output": "6069.397933300514"
      },
      {
        "input": "10 20 30 40",
        "output": "6783.751974994595"
      }
    ]
  },
  "solution #33": {
    "solution": "#lang racket\n;; Find the n-th number in the Newman-Conway sequence, which is defined by P(1) = 1, P(2) = 1, and P(n) = P(P(n-1)) + P(n - P(n-1)) for n > 2.\n;; A single integer n (1 \u2264 n \u2264 12000), given in a separate line.\n;; A single integer, the n-th term of the sequence, followed by a newline.The order corresponds to the Fibonacci sequence is defined as a number\n;; input_format\n;; A single integer representing the n-th-term of the sequence, or the string 'None' otherwise.\n#lang racket\n\n(define (find-n-1) (define n (read-line))\n(define n-as-integer (string->number n))\n(define (main)\n  (define (main)\n    (let ((num (string->number n)))\n      (display (find-n-1)",
    "unclipped": " The order corresponds to the Fibonacci sequence is defined as a number\n;; input_format\n;; A single integer representing the n-th-term of the sequence, or the string 'None' otherwise.\n#lang racket\n\n(define (find-n-1) (define n (read-line))\n(define n-as-integer (string->number n))\n(define (main)\n  (define (main)\n    (let ((num (string->number n)))\n      (display (find-n-1) num)))\n    (newline)))\n\n(main)\n(main)\n    (displayln (find-n-2))\n    (newline)))\n\n(main)\n    (newline\n    (displayln (find-n-1))\n    (displayln \"None\"))\n    (newline)))\n\n(main)\n    (newline\n    (displayln (find-n-2))\n    (newline)))\n\n(main)\n    (displayln \"None\"))\n    (displayln \"Odd\"))\n    (displayln \"None\"))))\n\n(main)\n    (displayln (find-n-2))\n    (newline)))\n\n(main)\n    (displayln (find-n-2))\n    (newline)))\n\n(main)\n    (displayln (displayln \"None\"))\n    (newline)))\n\n(main)\n    (displayln (find-n-2))\n    (newline)))\n\n(main)\n    (displayln (displayln \"None\"))\n    (newline)))\n\n(main)\n    (displayln (find-n-2))\n    (newline)))\n\n(main)\n    (displayln (displayln \"None\"))\n    (newline)))\n\n(main)\n    (displayln (find-n-2))\n    (newline)))\n\n(main)\n    (displayln (displayln \"None\"))\n    (newline)))\n\n(main)\n    (displayln (find-n-2))))\n\n(main)\n    (displayln (displayln \"None\"))))\n\n(main)\n    (displayln (find-n-2))))\n\n(main)\n    (displayln (displayln \"None\"))\n    (newline)))\n\n(main)\n    (displayln (find-n-2))\n    (newline)))\n\n(main)\n    (displayln (displayln \"None\"))\n    (newline)))\n\n(main)\n    (displayln (find-n-2))\n    (newline)))\n\n(main)\n    (displayln (displayln \"None\"))\n    (newline)))\n\n(main)\n    (displayln (find-n-2))\n    (newline)))\n\n(main)\n    (displayln (displayln \"None\"))))\n\n(main)\n    (displayln (find-n-2))))\n\n(main)\n    (displayln",
    "inputs": "A single integer n (1 \u2264 n \u2264 12000), given in a separate line.",
    "outputs": "A single integer, the n-th term of the sequence, followed by a newline.",
    "tests": [
      {
        "input": "10",
        "output": "6"
      },
      {
        "input": "2",
        "output": "1"
      },
      {
        "input": "3",
        "output": "2"
      }
    ]
  },
  "solution #34": {
    "solution": "#lang racket\n;; Write a function to remove specific words from a given list. The function should take two lists as input: the first is the original list of words, and the second contains the words to remove. The output should be a new list with the specified words removed, preserving the original order of the remaining elements.\n;; Two lines of input. The first line contains space-separated words from the original list. The second line contains space-separated words to remove.\n;; A single line containing the filtered list of words, separated by spaces.Each word is the same as an integer (the list after removing duplicate words).\n;; input_format\n;; A single line containing space-separated integers representing the filtered list.\n#lang racket\n\n(define (remove-duplicates words)\n  (let loop ((words words)\n             (seen '())\n             (result '()))\n    (if (null? words)\n        (reverse result)\n        (let ((current (car words)))\n          (if (member current seen)\n              (loop (cdr words) seen result)\n              (loop (cdr words) (cons current seen) (cons current result)))))))\n\n(define input (string-split (read-line)))\n(define output (remove-duplicates input)",
    "unclipped": " Each word is the same as an integer (the list after removing duplicate words).\n;; input_format\n;; A single line containing space-separated integers representing the filtered list.\n#lang racket\n\n(define (remove-duplicates words)\n  (let loop ((words words)\n             (seen '())\n             (result '()))\n    (if (null? words)\n        (reverse result)\n        (let ((current (car words)))\n          (if (member current seen)\n              (loop (cdr words) seen result)\n              (loop (cdr words) (cons current seen) (cons current result)))))))\n\n(define input (string-split (read-line)))\n(define output (remove-duplicates input))\n(printf \"~a\\n\" (string-join output \" \"))\n(newline)\n  (let ((current (car output)))\n    (if (null? current)\n        (loop (cdr words) seen result)\n        (loop (cdr words) (cons current seen) (cons current result)))))))\n\n(printf \"~a\\n\" (string-join (remove-duplicates input) \" \"))\n(newline)\n  (let ((current (car input)))\n    (if (null? result)\n        (loop (cdr words) seen result)\n        (loop (cdr words) (cons current seen) (cons current result))))))\n\n(printf \"~a\\n\" (string-join (remove-duplicates (remove-duplicates input)) \" \"))\n(newline)\n  (let ((current (car input)))\n    (if (null? current)\n        (loop (cdr words) seen result)\n        (loop (cdr words) (cons current seen) (cons current result)))))))\n\n(printf \"~a\\n\" (string-join (remove-duplicates (string-split (read-line)))\n(define result (remove-duplicates (string-join result \" \")))\n(newline result)\n  (displayln result))\n\n(newline result)\n(newline)\n(newline result)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline result)\n(newline)\n(newline)\n(newline)\n(newline result)\n(newline)\n(newline result)\n(newline)\n(newline)\n(newline result)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(newline)\n(new",
    "inputs": "Two lines of input. The first line contains space-separated words from the original list. The second line contains space-separated words to remove.",
    "outputs": "A single line containing the filtered list of words, separated by spaces.",
    "tests": [
      {
        "input": "red green blue white black orange\nwhite orange",
        "output": "red green blue black"
      },
      {
        "input": "red green blue white black orange\nblack orange",
        "output": "red green blue white"
      },
      {
        "input": "red green blue white black orange\nblue white",
        "output": "red green black orange"
      }
    ]
  },
  "solution #35": {
    "solution": "#lang racket\n;; Count the number of prime numbers less than a given non-negative number.\n;; A single integer n (non-negative) provided as input.\n;; An integer output representing the count of primes less than n, followed by a newline.The count of divisors is even or odd.\n;; input_format\n;; A single integer representing the count of divisors even or odd.\n#lang racket\n\n(define (count-divisors-even-or-odd n)\n  (define (is-divisible? n d)\n    (= (remainder n d) 0))\n  \n  (define (count-divisors-even-or-odd n)",
    "unclipped": " The count of divisors is even or odd.\n;; input_format\n;; A single integer representing the count of divisors even or odd.\n#lang racket\n\n(define (count-divisors-even-or-odd n)\n  (define (is-divisible? n d)\n    (= (remainder n d) 0))\n  \n  (define (count-divisors-even-or-odd n)\n    (let ((sqrt-n+1 (sqrt n)))\n      (if (integer? sqrt-n+1)\n          0\n          (+ (remainder n 2) (count-divisors-even-or-odd n)))))))\n\n  (count-divisors-even-or-odd n))\n\n(define (main)\n  (let ((n (string->number (read-line))))\n    (display (count-divisors-even-or-odd n))))\n\n(main)\n    (newline)))\n\n(main)\n    (display (count-divisors-even-or-odd n))))\n\n(main)\n    (newline)))\n\n(main)\n    (displayln (count-divisors-even-or-odd n))))\n\n(main)\n    (newline)))\n\n(main)\n    (displayln (count-divisors-even-or-odd n))))\n\n(main)\n    (newline)))\n\n(main)\n    (displayln (count-divisors-even-or-odd n))))\n\n(main)\n    (newline)))\n\n(main)\n    (displayln (count-divisors-even-or-odd n))))\n\n(main)\n    (newline)))\n\n(main)\n    (displayln (count-divisors-even-or-odd n))))\n\n(main)\n    (newline)))\n\n(main)\n    (displayln (count-divisors-even-or-odd n))))\n\n(main)\n    (newline)))\n\n(main)\n    (displayln (count-divisors-even-or-odd n))))\n\n(main)\n    (newline)))\n\n(main)\n    (displayln (count-divisors-even-or-odd n))))\n\n(main)\n    (newline)))\n\n(main)\n    (displayln (count-divisors-even-or-odd n))))\n\n(main)\n    (newline)))\n\n(main)\n    (displayln (count-divisors-even-or-odd n))))\n\n(main)\n    (newline)))\n\n(main)\n    (displayln (count-divisors-even-or-odd n))))\n\n(main)\n    (newline)))\n\n(main)\n    (displayln (count-divisors-even-or-odd n))))\n\n(main)\n    (newline)))\n\n(main)\n    (displayln (count-divisors-even-or-odd n))))\n\n(main)\n    (newline)))\n\n(main)\n    (displayln (count-divisors-even-or-odd n))))\n\n(main)\n    (newline)))\n\n",
    "inputs": "A single integer n (non-negative) provided as input.",
    "outputs": "An integer output representing the count of primes less than n, followed by a newline.",
    "tests": [
      {
        "input": "5",
        "output": "2"
      },
      {
        "input": "10",
        "output": "4"
      },
      {
        "input": "100",
        "output": "25"
      }
    ]
  },
  "solution #36": {
    "solution": "#lang racket\n;; Write a function to find the area of a rectangle given its length and width.\n;; Two integers on the same line, separated by a space. The first integer represents the length, and the second represents the width of the rectangle.\n;; A single integer representing the area of the rectangle, followed by a newline.The area is calculated as b^2 - 4ac. Return a tuple containing the type of solution (\"Two solutions\" if area > 0, \"no real solution\" if < 0, \"one solution\" if = 0) and the computed discriminant value.\n;; input_format\n;; A string indicating the solution type followed by a newline.\n#lang racket\n\n(define (quadratic-solution a b c)\n  (let* ([discriminant (- (* b b) (* 4 a c))])\n    (cond\n      [(> discriminant 0) (string-append \"Two solutions \" (number->string discriminant))]\n      [(= discriminant 0) (string-append \"one solution \" (number->string discriminant))]\n      [(< discriminant 0) (string-append \"no real solution \" (number->string discriminant))])))\n\n(define (main)\n  (let ([input (read-line)])\n    (let ([values (map string->number (string-split input \" \"))])\n      (let ([a (car values)]\n            [b (cadr values)]\n            [c (caddr values)])\n        (displayln (quadratic-solution a b c)",
    "unclipped": " The area is calculated as b^2 - 4ac. Return a tuple containing the type of solution (\"Two solutions\" if area > 0, \"no real solution\" if < 0, \"one solution\" if = 0) and the computed discriminant value.\n;; input_format\n;; A string indicating the solution type followed by a newline.\n#lang racket\n\n(define (quadratic-solution a b c)\n  (let* ([discriminant (- (* b b) (* 4 a c))])\n    (cond\n      [(> discriminant 0) (string-append \"Two solutions \" (number->string discriminant))]\n      [(= discriminant 0) (string-append \"one solution \" (number->string discriminant))]\n      [(< discriminant 0) (string-append \"no real solution \" (number->string discriminant))])))\n\n(define (main)\n  (let ([input (read-line)])\n    (let ([values (map string->number (string-split input \" \"))])\n      (let ([a (car values)]\n            [b (cadr values)]\n            [c (caddr values)])\n        (displayln (quadratic-solution a b c))))))\n\n(main)\n  (displayln \"No real solution \" (number->string (quadratic-solution a b c))))))\n\n(main)\n  (displayln (quadratic-solution a b c)))\n\n(main)\n  (displayln \"No real solution \" (number->string (quadratic-solution a b c))))))\n\n(main)\n  (displayln (quadratic-solution a b c)))\n\n(main)\n  (displayln \"No real solution \" (number->string (quadratic-solution a b c))))))\n\n(main)\n  (displayln \"No real solution \" (number->string (quadratic-solution a b c))))))\n\n(main)\n  (displayln \"No real solution \" (number->string (quadratic-solution a b c))))))\n\n(main)\n  (displayln \"No real solution \" (number->string (quadratic-solution a b c))))))\n\n(main)\n  (displayln \"No real solution \" (number->string (quadratic-solution a b c))))))\n\n(main)\n  (displayln \"No real solution \" (number->string (quadratic-solution a b c))))))\n\n(main)\n  (displayln \"No real solution \" (number->string (quadratic-solution a",
    "inputs": "Two integers on the same line, separated by a space. The first integer represents the length, and the second represents the width of the rectangle.",
    "outputs": "A single integer representing the area of the rectangle, followed by a newline.",
    "tests": [
      {
        "input": "10 20",
        "output": "200\n"
      },
      {
        "input": "10 5",
        "output": "50\n"
      },
      {
        "input": "4 2",
        "output": "8\n"
      }
    ]
  },
  "solution #37": {
    "solution": "#lang racket\n;; Find the first element in an array that occurs exactly k times.\n;; The first line contains the array elements as space-separated integers. The second line contains an integer n (the length of the array). The third line contains an integer k.\n;; A single integer, the first element occurring exactly k times.It is n+1.\n;; Read the input array elements from the first line of input\n(define arr (map string->number (string-split (read-line))))\n\n(define k (string->number (read-line)))\n\n(define result (map (lambda (x) (expt x k)) arr))\n(printf \"~a\\n\" result)\n(printf \"~a\\n\" (string-join (map number->string result) \" \"))",
    "unclipped": " It is n+1.\n;; Read the input array elements from the first line of input\n(define arr (map string->number (string-split (read-line))))\n\n(define k (string->number (read-line)))\n\n(define result (map (lambda (x) (expt x k)) arr))\n(printf \"~a\\n\" result)\n(printf \"~a\\n\" (string-join (map number->string result) \" \"))\n))\n  (displayln result))\n\n(find-first-1)\n  (displayln result))\n\n(find-first-2)\n  (displayln result))\n\n(find-first-1)\n  (displayln result))\n\n(find-first-1)\n  (displayln result))\n\n(find-first-2)\n  (displayln result))\n\n(find-first-1)\n  (displayln result))\n\n(find-first-1)\n  (displayln result))\n\n(find-first-2)\n  (displayln result))\n\n(find-first-1)\n  (displayln result))\n\n(find-first-1)\n  (displayln result))\n\n(find-first-2)\n  (displayln result))\n\n(find-first-1)\n  (displayln result))\n\n(find-first-1)\n  (displayln result))\n\n(find-first-2)\n  (displayln result))\n\n(find-first-1)\n  (displayln result))\n\n(find-first-1)\n  (displayln result))\n\n(find-first-2)\n  (displayln result))\n\n(find-first-1)\n  (displayln result))\n\n(find-first-1)\n  (displayln result))\n\n(find-first-2)\n  (displayln result))\n\n(find-first-1)\n  (displayln result))\n\n(find-first-2)\n  (displayln result))\n\n(find-first-1)\n  (displayln result))\n\n(find-first-1)\n  (displayln result))\n\n(find-first-2)\n  ((newline result))\n\n(find-first-1)\n  ((newline result))\n\n(new-l result)\n  (displayln result))\n\n(new-l result)\n(new-l result)\n(new-l result)\n(new-l new-l result)\n(new-l new-l results)\n(new-l new-l result)\n(new-l new-l results)\n(new-l new-l results)\n(new-l new-l results)\n(new-l new-l results)\n(new-l new-l results)\n(new-l new-l results)\n(new-l new-l results)\n(new-l new-l results)\n(new-l new-l results)\n(new-l new-l results)\n(new-l new-l results)\n(new-l new-l results)\n(new-l new-l results)\n(new-l",
    "inputs": "The first line contains the array elements as space-separated integers. The second line contains an integer n (the length of the array). The third line contains an integer k.",
    "outputs": "A single integer, the first element occurring exactly k times.",
    "tests": [
      {
        "input": "0 1 2 3 4 5\n6\n1",
        "output": "0"
      },
      {
        "input": "1 2 1 3 4\n5\n2",
        "output": "1"
      },
      {
        "input": "2 3 4 3 5 7 1 2 3 5\n10\n2",
        "output": "2"
      }
    ]
  },
  "solution #38": {
    "solution": "#lang racket\n;; Find the first digit of a given number.\n;; A single line containing the number as a string.\n;; A single line containing the first digit as a string.Return 'None' if there is no digit. Return 'None' if there is no digit. Return 'None' if there is no digit. Return 'None' if there is no digit. Return 'None' if there is no digit. Return 'None' if there is no digit. Return 'None' if there is no digit. Return 'None' if there is no digit. Return 'None' if there is no digit. Return 'None' if there is no digit. Return 'None' if there is no digit. Return 'None' if there is no digit. Return 'None' if no digit is found.\n;; input_format\n;; A single line containing the string 'None'.\n#lang racket\n\n(define (first-digits s)\n  (if (empty? s)\n      #f\n      (let loop ((i 0))\n        (if (> i (string-length s))\n            #f\n            (let ((ch (string-ref s i)))\n              (if (char-numeric? ch)\n                  (loop (+ i 1))\n                  (loop (+ i 1)))))))\n\n(define s (read-line))\n(first-digits s)",
    "unclipped": " Return 'None' if there is no digit. Return 'None' if there is no digit. Return 'None' if there is no digit. Return 'None' if there is no digit. Return 'None' if there is no digit. Return 'None' if there is no digit. Return 'None' if there is no digit. Return 'None' if there is no digit. Return 'None' if there is no digit. Return 'None' if there is no digit. Return 'None' if there is no digit. Return 'None' if there is no digit. Return 'None' if no digit is found.\n;; input_format\n;; A single line containing the string 'None'.\n#lang racket\n\n(define (first-digits s)\n  (if (empty? s)\n      #f\n      (let loop ((i 0))\n        (if (> i (string-length s))\n            #f\n            (let ((ch (string-ref s i)))\n              (if (char-numeric? ch)\n                  (loop (+ i 1))\n                  (loop (+ i 1)))))))\n\n(define s (read-line))\n(first-digits s)\n  (if (zero? s)\n      (loop (+ i 1)))\n      (loop 0))\n    (cond\n      ((= i (string-length s)) #t)\n      ((zero? (string-ref s i))\n       (loop (+ i 1)))\n      (else\n       (loop (+ i 1))))))\n\n(define s (read-line))\n(first-digits s)\n            (loop (+ i 1))))))\n\n(define s (car s))\n(printf \"~a\\n\" (first-digits s))\n            (loop (+ i 1))))))\n\n(if no digit is found\n            (loop (add1 i) d)\n            (loop (add1 i))))))\n\n(define (main)\n  (let ((input (read-line)))\n    (let ((ch (string->number input)))\n      (if (zero? ch)\n          (let ((result (first-digits s)))\n            (if result\n                (displayln result)\n                (displayln \"None\")))\n          (displayln \"None\"))))\n\n(main)\n(main)\n  (let ((ch (string->number (read-line))))\n    (displayln (first-digits ch))))\n\n(main)\n(main)\n  (displayln (string-append s ch)))\n  (displayln \"None\"))))\n\n(main)\n",
    "inputs": "A single line containing the number as a string.",
    "outputs": "A single line containing the first digit as a string.",
    "tests": [
      {
        "input": "123",
        "output": "1"
      },
      {
        "input": "456",
        "output": "4"
      },
      {
        "input": "12",
        "output": "1"
      }
    ]
  },
  "solution #39": {
    "solution": "#lang racket\n;; Compute the nth hexagonal number using the formula n*(2n - 1).\n;; A single integer n.\n;; The nth hexagonal number as an integer.The Jacobsthal sequence is defined by J(0) = 0, J(1) = 1, and J(n) = n-1) + 2*J(n-1) + 2*J(n-2) for n \u2265 2.\n;; input_format\n;; The nth Jacobsthal number.\n#lang racket\n\n(define (jacobsthal n)\n  (if (= n 0)\n      0\n      (let loop ((i 2) (a 1) (b 1))\n        (if (> i n)\n            b\n            (loop (+ i 1) b (+ a b))))))\n\n(define n (string->number (read-line)))\n(printf \"~a\\n\" (jacobsthal n)",
    "unclipped": " The Jacobsthal sequence is defined by J(0) = 0, J(1) = 1, and J(n) = n-1) + 2*J(n-1) + 2*J(n-2) for n \u2265 2.\n;; input_format\n;; The nth Jacobsthal number.\n#lang racket\n\n(define (jacobsthal n)\n  (if (= n 0)\n      0\n      (let loop ((i 2) (a 1) (b 1))\n        (if (> i n)\n            b\n            (loop (+ i 1) b (+ a b))))))\n\n(define n (string->number (read-line)))\n(printf \"~a\\n\" (jacobsthal n))\n(printf \"~a\\n\" (jacobsthal n))\n            (printf \"a\\n\" (jacobsthal n))))))\n\n(printf \"~a\\n\" (jacobsthal n))\n            (printf \"a\\n\" (jacobsthal n))))\n              (loop b (+ a 1) b (+ n 1)))\n              (loop b (+ a 1) b (+ n 1)))))))\n\n(printf \"~a\\n\" (jacobsthal n))\n(printf \"~a\\n\" (jacobsthal n))\n            (loop b (+ a 1) b (+ b 1)))\n              (loop b 2 n (+ a b) b))))\n            (if (= b 0)\n                (loop (+ i 1) b (+ a b)))\n                  (+ b 1))))))\n\n(printf \"~a\\n\" (jacobsthal n))\n(printf \"~a\\n\" (jacobsthal n))\n            (loop (+ i 1) b (+ a b))))))\n\n(printf \"~a\\n\" (jacobsthal n))\n            (loop (+ i 1) b (+ a b))))))\n\n(printf \"~a\\n\" (jacobsthal n))\n            (loop (+ i 1) b (+ a b))))))\n\n(printf \"~a\\n\" (jacobsthal n))\n            (loop (+ i 1) b (+ a b))))))\n\n(printf \"~a\\n\" (jacobsthal n))\n            (loop (+ i 1) b (+ a b))))))\n\n(printf \"~a\\n\" (jacobsthal n))\n            (loop (+ i 1) b (+ a b",
    "inputs": "A single integer n.",
    "outputs": "The nth hexagonal number as an integer.",
    "tests": [
      {
        "input": "10",
        "output": "190"
      },
      {
        "input": "5",
        "output": "45"
      },
      {
        "input": "7",
        "output": "91"
      }
    ]
  },
  "solution #40": {
    "solution": "#lang racket\n;; Write a function to zip the two given tuples. The tuples are zipped by pairing elements at the same index, cycling through the shorter tuple as needed.\n;; The input consists of two lines. The first line contains space-separated integers representing the elements of the first tuple. The second line contains space-separated integers representing the elements of the second tuple.\n;; The output consists of multiple lines. Each line contains two space-separated integers representing a pair from the zipped tuples. The pairs are ordered according to the zipping process, cycling through the shorter tuple as needed.The output is a single line containing space-separated integers representing the elements of the concatenated tuple, separated by spaces.\n;; input_format\n;; A single line containing space-separated integers representing the elements of the concatenated tuple, separated by spaces.\n#lang racket\n\n(define (zip-lists list1 list2)\n  (append list1 list2))\n\n(define (main)\n  (let* ([input (string-split (read-line) \" \")]\n         [tuple1 (map string->number (take input (sub1 (length input)))])\n    (displayln (string-join (map number->string (zip-lists tuple1 tuple2)",
    "unclipped": " The output is a single line containing space-separated integers representing the elements of the concatenated tuple, separated by spaces.\n;; input_format\n;; A single line containing space-separated integers representing the elements of the concatenated tuple, separated by spaces.\n#lang racket\n\n(define (zip-lists list1 list2)\n  (append list1 list2))\n\n(define (main)\n  (let* ([input (string-split (read-line) \" \")]\n         [tuple1 (map string->number (take input (sub1 (length input)))])\n    (displayln (string-join (map number->string (zip-lists tuple1 tuple2)) \" \"))))\n\n(main)\n  (displayln (string-join (map number->string (zip-lists tuple1 tuple2)) \" \"))))\n\n(main)\n  (displayln (string-join (map number->string (zip-lists tuple1 tuple2)) \" \")))\n\n(main)\n  (displayln (string-join (map number->string (zip-lists tuple1 tuple2)) \" \")))\n\n(main)\n  (displayln (string-join (map number->string (zip-lists tuple1 tuple2)) \" \")))\n\n(main)\n  (displayln (string-join (map number->string (zip-lists tuple1 tuple2)) \" \"))))\n\n(main)\n  (displayln (string-join (map number->string (zip-lists tuple1 tuple2)) \" \"))))\n\n(main)\n  (displayln (string-join (map number->string (zip-lists tuple1 tuple2)) \" \")))\n\n(main)\n  (displayln (string-join (map number->string (zip-lists tuple1 tuple2)) \" \"))))\n\n(main)\n  (displayln (string-join (map number->string (zip-lists tuple1 tuple2)) \" \")))\n\n(main)\n  (displayln (string-join (map number->string (zip-lists tuple1 tuple2)) \" \"))))\n\n(main)\n  (displayln (string-join (map number->string (zip-lists tuple1 tuple2)) \" \")))\n\n(main)\n  (displayln (string-join (map number->string (zip-lists tuple1 tuple2)) \" \"))))\n\n(main)\n  (displayln (string-join (map number->string (zip-lists tuple1 tuple2)) \" \"))))\n\n(main)\n  (displayln (string-join (map number->string (",
    "inputs": "The input consists of two lines. The first line contains space-separated integers representing the elements of the first tuple. The second line contains space-separated integers representing the elements of the second tuple.",
    "outputs": "The output consists of multiple lines. Each line contains two space-separated integers representing a pair from the zipped tuples. The pairs are ordered according to the zipping process, cycling through the shorter tuple as needed.",
    "tests": [
      {
        "input": "7 8 4 5 9 10\n1 5 6",
        "output": "7 1\n8 5\n4 6\n5 1\n9 5\n10 6"
      },
      {
        "input": "8 9 5 6 10 11\n2 6 7",
        "output": "8 2\n9 6\n5 7\n6 2\n10 6\n11 7"
      },
      {
        "input": "9 10 6 7 11 12\n3 7 8",
        "output": "9 3\n10 7\n6 8\n7 3\n11 7\n12 8"
      }
    ]
  },
  "solution #41": {
    "solution": "#lang racket\n;; Check whether all the characters in a given string are unique.\n;; A single line containing the input string.\n;; A single line containing 'True' or 'False'.Each character is either an integer or the string 'None'.\n;; input_format\n;; Each character in the string 'None'.\n#lang racket\n\n(define (is-strictly-increasing s)\n  (regexp-match? #px\"^[^a-zA-Z0-9]+$\" s))\n\n(define s (read-line))\n(printf \"~a\\n\" (if (is-strictly-increasing s)",
    "unclipped": " Each character is either an integer or the string 'None'.\n;; input_format\n;; Each character in the string 'None'.\n#lang racket\n\n(define (is-strictly-increasing s)\n  (regexp-match? #px\"^[^a-zA-Z0-9]+$\" s))\n\n(define s (read-line))\n(printf \"~a\\n\" (if (is-strictly-increasing s) \"True\" \"False\"))\n(printf \"~a\\n\" (if (regexp-match? #px\"^[a-zA-Z0-9]+$\" s) \"True\" \"False\"))\n  (printf \"False\\n\"))\n\n(define s (read-line))\n(printf \"~a\\n\" (if (is-strictly-increasing s) \"True\" \"False\"))\n  (printf \"False\\n\"))\n\n(printf \"~a\\n\" (if (regexp-match? #px\"^[a-zA-Z0-9]+$\" s) \"True\" \"False\"))\n  (printf \"False\\n\"))\n\n(if (regexp-match? #px\"^[a-zA-Z0-9]+$\" s)\n      \"True\"\n      \"False\"))\n\n(printf \"~a\\n\" (if (regexp-match? #px\"\\\\s\" s) \"True\" \"False\"))\n      \"False\"))\n  (printf \"False\\n\"))\n\n(printf \"~a\\n\" (if (regexp-match? #px\"\\\\s\" s) \"True\" \"False\"))\n  (printf \"False\\n\"))\n\n(define s (read-line))\n(printf \"~a\\n\" (if (regexp-match? #px\"\\\\s\" s) \"True\" \"False\"))\n  (printf \"False\\n\"))\n\n(if s)\n      \"True\"\n      \"False\"))\n\n(printf \"~a\\n\" (if (regexp-match? #px\"\\\\s\" s) \"True\" \"False\"))\n      \"False\"))\n  (printf \"False\\n\"))\n\n(printf \"~a\\n\" (if (regexp-match? #px\"\\\\s\" s) \"True\" \"False\"))\n  (printf \"False\\n\"))\n\n(if s)\n      \"True\"\n      \"False\"))\n\n(printf \"~a\\n\" (if (regexp-match? #px\"\\\\s\" s) \"True\" \"False\"))\n  (printf \"False\\n\"))\n\n(printf \"~a\\n\" (if (regexp-match? #px\"\\\\s\" s) \"True\" \"False\"))\n  (printf \"False\\n\"))\n\n(if s)\n     ",
    "inputs": "A single line containing the input string.",
    "outputs": "A single line containing 'True' or 'False'.",
    "tests": [
      {
        "input": "aba",
        "output": "False"
      },
      {
        "input": "abc",
        "output": "True"
      },
      {
        "input": "abab",
        "output": "False"
      }
    ]
  },
  "solution #42": {
    "solution": "#lang racket\n;; Write a function to calculate the sum of all integers in a nested list using recursion.\n;; A single line containing a nested list of integers in Python syntax, e.g., [1, 2, [3,4], [5,6]]\n;; A single integer representing the sum of all elements in the nested list, printed on a single line.\n;; input_format\n;; A single integer representing the sum of all elements in the extra list.\n#lang racket\n\n(define (sum-of-factors list)\n  (if (null? list)\n      0\n      (let loop ((i 0) (total 0))\n        (if (> i (sub1 (length list))) 0\n            (let* ((current (list-ref list i))\n                  (if (< (loop (+ i 1) current)\n                  (loop (+ i 1) current)\n                  (loop (+ i 1) (+ current (list-ref list i))))))))\n\n(define (main)\n  (let* ((input (string-split (read-line) \" \"))\n         (nums (map string->number input)))\n    (display (sum-of-factors nums)",
    "unclipped": ".\n;; input_format\n;; A single integer representing the sum of all elements in the extra list.\n#lang racket\n\n(define (sum-of-factors list)\n  (if (null? list)\n      0\n      (let loop ((i 0) (total 0))\n        (if (> i (sub1 (length list))) 0\n            (let* ((current (list-ref list i))\n                  (if (< (loop (+ i 1) current)\n                  (loop (+ i 1) current)\n                  (loop (+ i 1) (+ current (list-ref list i))))))))\n\n(define (main)\n  (let* ((input (string-split (read-line) \" \"))\n         (nums (map string->number input)))\n    (display (sum-of-factors nums))))\n\n(main)\n    (let ((result (sum-of-factors nums)))\n      (display (number->string result)))))\n\n(main)\n    (let ((nums (map number->string result)))\n      (display (number->string nums) \" \")))\n\n(main)\n    (let ((result (sum-of-factors nums)))\n      (display (number->string result)))))\n\n(main)\n    (let ((nums (map number->string result)))\n      (display (string-join (map number->string result) \" \")))))\n\n(main)\n    (displayln result)))\n\n(main)\n    (displayln result)))\n\n(main)\n    (newline\n    (newline)))\n\n(main)\n    (displayln (sum-of-factors nums))))\n\n(main)\n    (displayln (number->string result))\n    (newline)))\n\n(main)\n    (newline)))\n\n(main)\n    (displayln (string-join (map number->string result) \" \"))))\n\n(main)\n    (displayln result)))\n\n(main)\n    (displayln result)))\n\n(main)\n    (displayln result)))\n\n(main)\n    (displayln result)))\n\n(main)\n    (displayln result)))\n\n(main)\n    (displayln result)))\n\n(main)\n    (displayln result)))\n\n(main)\n    (displayln (number->string result)))\n    (newline)))\n\n(main)\n    (displayln (string-join (map number->string result) \" \"))))\n\n(main)\n    (displayln result)))\n\n(main)\n    (displayln result)))\n\n(main)\n    (newline)))\n\n(main)\n    (displayln result)))\n\n(main)\n    (displayln result)))\n\n(main)\n    (displayln result)))\n\n(main)\n    (displayln result)))\n\n(main)\n    (",
    "inputs": "A single line containing a nested list of integers in Python syntax, e.g., [1, 2, [3,4], [5,6]]",
    "outputs": "A single integer representing the sum of all elements in the nested list, printed on a single line",
    "tests": [
      {
        "input": "[1, 2, [3,4], [5,6]]",
        "output": "21"
      },
      {
        "input": "[7, 10, [15,14], [19,41]]",
        "output": "106"
      },
      {
        "input": "[10, 20, [30,40], [50,60]]",
        "output": "210"
      }
    ]
  },
  "solution #43": {
    "solution": "#lang racket\n;; Write a function to find the item with maximum frequency in a given list. If multiple items have the same maximum frequency, return the one that appeared first.\n;; A list of integers separated by spaces.\n;; Two integers separated by a space: the item with maximum frequency and its count.The four items have the same maximum number of occurrences, return the one that appears first in the list.\n;; input_format\n;; A single integer, printed on a single line, representing the item with maximum occurrences.\n#lang racket\n\n(define (find-most-frequent-item list)\n  (define counts (make-hash))\n  (define max-count 0)\n  (define result-item 0)\n  \n  (for ([item list])\n    (hash-set! counts item (add1 (hash-ref counts item 0)))\n    (when (> (hash-ref counts item) max-count)\n      (set! max-count (hash-ref counts item))\n      (set! result-item item)))\n  \n  result-item)\n\n(define input (string-split (read-line) \" \"))\n(define numbers (map string->number input))\n(printf \"~a\\n\" (find-most-frequent-item numbers)",
    "unclipped": " The four items have the same maximum number of occurrences, return the one that appears first in the list.\n;; input_format\n;; A single integer, printed on a single line, representing the item with maximum occurrences.\n#lang racket\n\n(define (find-most-frequent-item list)\n  (define counts (make-hash))\n  (define max-count 0)\n  (define result-item 0)\n  \n  (for ([item list])\n    (hash-set! counts item (add1 (hash-ref counts item 0)))\n    (when (> (hash-ref counts item) max-count)\n      (set! max-count (hash-ref counts item))\n      (set! result-item item)))\n  \n  result-item)\n\n(define input (string-split (read-line) \" \"))\n(define numbers (map string->number input))\n(printf \"~a\\n\" (find-most-frequent-item numbers))\n  (displayln (string-join (map number->string max-count) \" \")))\n\n(find-most-frequent-item numbers)\n  (define max-count (hash-ref counts item))\n  (displayln max-count))\n\n(find-most-frequent-item numbers)\n  (number->string max-count))\n\n(find-most-frequent-item numbers)\n  (cond\n    [(empty? numbers) '()]\n    [(= (hash-ref counts item) max-count)\n     (set! max-count (hash-ref counts item))\n     max-count))\n\n(find-most-frequent-item numbers)\n      (when (< (hash-ref counts item) max-count)\n        (set! max-count (hash-ref counts item))\n        (when (< (hash-ref counts item) max-count)\n          (set! max-count (hash-ref counts item))\n          (when (< (hash-ref counts item) max-count)\n            (set! result-item item))\n            (when (< (hash-ref counts item) max-count)\n              (set! max-count (hash-ref counts item))\n              (set! result-item item)))\n        (when (= (hash-ref counts item) max-count)\n          (set! max-count (hash-ref counts item))\n          (when (< (hash-ref counts item) max-count)\n            (set! result-item item))\n            (when (< (hash-ref counts item) max-count)\n              (set! max-count (hash-ref counts item))\n              (set! result-item item)))\n        (when (= (hash-ref counts item) max-count)\n          (set! max-count (hash-ref counts item))\n         ",
    "inputs": "A list of integers separated by spaces.",
    "outputs": "Two integers separated by a space: the item with maximum frequency and its count.",
    "tests": [
      {
        "input": "2 3 8 4 7 9 8 2 6 5 1 6 1 2 3 2 4 6 9 1 2",
        "output": "2 5"
      },
      {
        "input": "2 3 8 4 7 9 8 7 9 15 14 10 12 13 16 16 18",
        "output": "8 2"
      },
      {
        "input": "10 20 20 30 40 90 80 50 30 20 50 10",
        "output": "20 3"
      }
    ]
  },
  "solution #44": {
    "solution": "#lang racket\n;; Write a function to remove the duplicates from the given tuple.\n;; A single line containing the elements of the tuple, enclosed in parentheses and separated by spaces.\n;; A single line containing the elements of the resulting tuple, enclosed in parentheses and separated by spaces.Each element is the same as a number. Elements are separated by spaces.\n;; input_format\n;; A single line containing space-separated integers representing the elements of the tuple.\n#lang racket\n\n(define (remove-duplicates-from-tuple)\n  (let* ([input (string-split (read-line))]\n         [numbers (map string->number input)]\n         [result (remove-duplicates-from-tuple)",
    "unclipped": " Each element is the same as a number. Elements are separated by spaces.\n;; input_format\n;; A single line containing space-separated integers representing the elements of the tuple.\n#lang racket\n\n(define (remove-duplicates-from-tuple)\n  (let* ([input (string-split (read-line))]\n         [numbers (map string->number input)]\n         [result (remove-duplicates-from-tuple)])\n    (displayln (string-join (map number->string result) \" \"))))\n\n(remove-duplicates-from-tuple)\n  (displayln (string-join (map number->string result) \" \")))\n\n(remove-duplicates-from-tuple)\n  (displayln result))\n\n(remove-duplicates-from-tuple)\n  (displayln -1)\n  ((newline -1)\n  ((newline -1)\n\n(remove-duplicates-from-tuple)\n  (displayln -1))\n\n(remove-duplicates-from-tuple)\n  ((newline -1)\n  ((newline -1))\n\n(newline -1)\n(newline -1)\n(newline -2)\n(newline -1)\n(newline -1)\n(newline -1)\n(newline -2)\n(newline -1)\n(newline -1)\n(newline -1)\n(newline -2)\n(newline -1)\n(newline -1)\n(newline -2)\n(newline -1)\n(newline -1)\n(newline -1)\n(newline -2)\n(newline -1)\n(newline -1)\n(newline -1)\n(newline -1)\n(newline -1)\n(newline -2)\n(newline -1)\n(newline -1)\n(newline -1)\n(newline -2)\n(newline -1)\n(newline -1)\n(newline -1)\n(newline -2)\n(newline -1)\n(newline -2)\n(newline -1)\n(newline -2)\n(newline -1)\n(newline -2)\n(newline -1)\n(newline -1)\n(newline -1)\n(newline -2)\n(newline -1)\n(newline -2)\n(newline -1)\n(newline -1)\n(newline -1)\n(newline -1)\n(newline -1)\n(newline -1)\n(newline -2)\n(newline -1)\n(newline -2)\n(newline -1)\n(newline -2)\n(newline -1)\n(newline -2)\n(newline -1)\n(newline -2)\n(newline -1)\n",
    "inputs": "A single line containing the elements of the tuple, enclosed in parentheses and separated by spaces.",
    "outputs": "A single line containing the elements of the resulting tuple, enclosed in parentheses and separated by spaces.",
    "tests": [
      {
        "input": "(1 3 5 2 3 5 1 1 3)",
        "output": "(1 2 3 5)"
      },
      {
        "input": "(2 3 4 4 5 6 6 7 8 8)",
        "output": "(2 3 4 5 6 7 8)"
      },
      {
        "input": "(11 12 13 11 11 12 14 13)",
        "output": "(11 12 13 14)"
      }
    ]
  },
  "solution #45": {
    "solution": "#lang racket\n;; Calculate the surface area of a cone given its radius and height. The formula is \u03c0r(r + sqrt(r\u00b2 + h\u00b2)), where r is the radius, h is the height, and sqrt(r\u00b2 + h\u00b2) is the slant height.\n;; Two space-separated numbers representing the radius and height of the cone.\n;; A single floating-point number representing the total surface area of the cone, printed with 14 decimal places.The total surface area is calculated using the formula \u03c0 * radius * slant_height, where slant_height is derived from radius and height using the Pythagorean theorem.\n;; input_format\n;; A single number representing the total surface area of the cone.\n#lang racket\n\n;; Function to calculate the surface area of a cone\n(define (surface-area radius height)\n  (let* ((slant-height (sqrt (+ (sqr radius) (sqr height))))\n         (area (* pi radius slant-height)))\n    area))\n\n;; Read input from standard input\n(define input (read-line))\n(define (split-into-numbers s)\n  (map string->number (string-split s)))\n\n;; Calculate and print the surface area\n(define radius (car radius))\n(define height (cadr radius))\n(printf \"~a\\n\" (surface-area radius height)",
    "unclipped": " The total surface area is calculated using the formula \u03c0 * radius * slant_height, where slant_height is derived from radius and height using the Pythagorean theorem.\n;; input_format\n;; A single number representing the total surface area of the cone.\n#lang racket\n\n;; Function to calculate the surface area of a cone\n(define (surface-area radius height)\n  (let* ((slant-height (sqrt (+ (sqr radius) (sqr height))))\n         (area (* pi radius slant-height)))\n    area))\n\n;; Read input from standard input\n(define input (read-line))\n(define (split-into-numbers s)\n  (map string->number (string-split s)))\n\n;; Calculate and print the surface area\n(define radius (car radius))\n(define height (cadr radius))\n(printf \"~a\\n\" (surface-area radius height))\n  (displayln total))\n    (number->string radius)))\n\n;; Main function to read input and print output\n(define (main)\n  (let* ((input (read-line))\n         (values (string-split input))\n         (a (string->number (car values)))\n         (b (string->number (cadr values)))\n    (displayln (surface-area a b))))\n\n(main)\n    (newline)))\n\n(main)\n    (displayln (surface-area radius height))))\n\n(main)\n    (newline\n    (displayln (surface-area radius height))))\n\n(main)\n    (newline\n    (displayln (surface-area radius height))))\n\n(main)\n    (newline\n    (displayln (surface-area radius height))))\n\n(main)\n    (newline\n    (displayln (surface-area radius height))))\n\n(main)\n    (newline\n    (displayln (surface-area radius height))))\n\n(main)\n    (newline\n    (displayln (surface-area radius height))))\n\n(main)\n    (newline\n    (displayln (surface-area radius height))))\n\n(main)\n    (newline\n    (displayln (surface-area radius height))))\n\n(main)\n    (newline\n    (newline)))\n\n(main)\n    (displayln (surface-area radius height))))\n\n(main)\n    (newline)))\n\n(main)\n    (displayln (surface-area radius height))))\n\n(main)\n    (newline)))\n\n(main)\n    (displayln (surface-area radius height))))\n\n(main)\n    (newline\n    (displayln (surface-area radius height))))\n\n(main)\n    (newline\n    (displayln (surface-area radius height))))\n\n(main)\n    (newline\n    (displayln (surface-area",
    "inputs": "Two space-separated numbers representing the radius and height of the cone.",
    "outputs": "A single floating-point number representing the total surface area of the cone, printed with 14 decimal places.",
    "tests": [
      {
        "input": "5 12",
        "output": "282.7433388230814"
      },
      {
        "input": "10 15",
        "output": "880.5179353159282"
      },
      {
        "input": "19 17",
        "output": "2655.923961165254"
      }
    ]
  },
  "solution #46": {
    "solution": "#lang racket\n;; Check whether the given number can be represented as difference of two squares or not.\n;; A single integer n.\n;; A boolean value (True or False) as a string.(False' or False is based on the condition check.\n;; input_format\n;; A single line containing either 'True' or 'False' based on the condition check.\n#lang racket\n\n(define (check-string s)\n  (if (regexp-match? #px\"^[a-zA-Z0-9]+$\" s)\n      \"True\"\n      \"False\"))\n\n(define s (read-line))\n(printf \"~a\\n\" (check-string s)",
    "unclipped": " (False' or False is based on the condition check.\n;; input_format\n;; A single line containing either 'True' or 'False' based on the condition check.\n#lang racket\n\n(define (check-string s)\n  (if (regexp-match? #px\"^[a-zA-Z0-9]+$\" s)\n      \"True\"\n      \"False\"))\n\n(define s (read-line))\n(printf \"~a\\n\" (check-string s))\n(printf \"~a\\n\" (if (regexp-match? #px\"\\\\d+\\\\.\\\\d{2})?$\" s \"False\"))\n(printf \"~a\\n\" (check-string s))\n  (if (regexp-match? #px\"\\\\d+\")\n      \"True\"\n      \"False\"))\n\n(printf \"~a\\n\" (check-string s))\n(printf \"~a\\n\" (check-string s))\n      \"True\" \"False\"))\n(printf \"~a\\n\" (check-string s))\n      \"False\"))\n(printf \"~a\\n\" (check-string s))\n      \"True\" \"False\"))\n(printf \"~a\\n\" (check-string s))\n      \"True\" \"False\"))\n(printf \"~a\\n\" (check-string s))\n      \"False\"))\n(printf \"~a\\n\" (check-string s))\n      \"True\" \"False\"))\n(printf \"~a\\n\" (check-string s))\n      \"False\"))\n(printf \"~a\\n\" (check-string s))\n      \"False\"))\n(printf \"~a\\n\" (check-string s))\n      \"True\" \"False\"))\n(printf \"~a\\n\" (check-string s))\n      \"False\"))\n(printf \"~a\\n\" (check-string s))\n      \"True\" \"False\"))\n(printf \"~a\\n\" (check-string s))\n      \"True\" \"False\"))\n(printf \"~a\\n\" (check-string s))\n      \"False\"))\n(printf \"~a\\n\" (check-string s))\n      \"False\"))\n(printf \"~a\\n\" (check-string s))\n      \"True\" \"False\"))\n(printf \"~a\\n\" (check-string s))\n      \"True\"))\n(printf \"~a\\n\" (check-string s))\n      \"False\"))\n(printf \"~a\\n\" (check-string s))\n      \"True\" \"False\"))\n(printf \"~a\\n\" (check-string s))\n      \"False\"))\n(printf \"~a\\n\" (check-string s))\n      \"False\"))\n(printf \"~a\\n\" (check",
    "inputs": "A single integer n.",
    "outputs": "A boolean value (True or False) as a string.",
    "tests": [
      {
        "input": "5",
        "output": "True"
      },
      {
        "input": "10",
        "output": "False"
      },
      {
        "input": "15",
        "output": "True"
      }
    ]
  },
  "solution #47": {
    "solution": "#lang racket\n;; Write a function to convert a snake case string to a camel case string.\n;; The input is a single line containing the snake case string.\n;; The output is a single line containing the camel case string.The output is a single line containing thecamel case string.\n;; input_format\n;; A single line containing thecamel case string.\n#lang racket\n\n(define (camel-to-snake s)\n  (let* ([trimmed (substring s 1 (- (string-length s) 1))] ; Remove the empty case string\n         [ch (make-vector (+ (string-length s) 1) 0)] ; One way to make 0\n         [camel (for/fold ([ch (in-string s)])\n                (let ([ch (string-ref s ch)])\n                  (if (string=? (substring s ch) \"\")\n                  (let ([ch (string-ref s ch)])\n                    (if (string=? (substring s ch) ch)\n                      (string-append s ch)\n                      s))\n        (string-append ch (substring s ch))))))\n\n(define s (read-line))\n(printf \"~a\\n\" (camel-to-snake s)",
    "unclipped": " The output is a single line containing thecamel case string.\n;; input_format\n;; A single line containing thecamel case string.\n#lang racket\n\n(define (camel-to-snake s)\n  (let* ([trimmed (substring s 1 (- (string-length s) 1))] ; Remove the empty case string\n         [ch (make-vector (+ (string-length s) 1) 0)] ; One way to make 0\n         [camel (for/fold ([ch (in-string s)])\n                (let ([ch (string-ref s ch)])\n                  (if (string=? (substring s ch) \"\")\n                  (let ([ch (string-ref s ch)])\n                    (if (string=? (substring s ch) ch)\n                      (string-append s ch)\n                      s))\n        (string-append ch (substring s ch))))))\n\n(define s (read-line))\n(printf \"~a\\n\" (camel-to-snake s))\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n    (printf \"None\\n\"))))\n\n(printf \"~a\\n\" (camel-to-snake s))\n   ",
    "inputs": "The input is a single line containing the snake case string.",
    "outputs": "The output is a single line containing the camel case string.",
    "tests": [
      {
        "input": "python_program",
        "output": "PythonProgram"
      },
      {
        "input": "python_language",
        "output": "PythonLanguage"
      },
      {
        "input": "programming_language",
        "output": "ProgrammingLanguage"
      }
    ]
  },
  "solution #48": {
    "solution": "#lang racket\n;; Determine if three given points form a valid triangle. A valid triangle is formed if the points are not collinear.\n;; Six space-separated integers representing the coordinates of three points: x1 y1 x2 y2 x3 y3\n;; A single line containing either 'Yes' if the points form a valid triangle, or 'No' otherwise.\n;; 'Ac'.\n;; The problem is to determine if a valid triangle has the sum of its angles exactly equal to 180 degrees and each angle is greater than 0.\n;; This is because a valid triangle has the sum of its angles exactly equal to 180 degrees and each angle is greater than 0.\n;; input_format\n;; A single line containing 'True' if the triangle is valid, 'False' otherwise.\n#lang racket\n\n(define (is-valid-triangle angles)\n  (let* ((a (first angles))\n         (b (second angles))\n         (c (third angles)))\n    (and (> a 0) (> b 0) (> c 0) (= (+ a b c) 180))))\n\n(define angles (map string->number (string-split (read-line) \" \")))\n\n(printf \"~a\\n\" (if (is-valid-triangle angles)",
    "unclipped": ".\n;; 'Ac'.\n;; The problem is to determine if a valid triangle has the sum of its angles exactly equal to 180 degrees and each angle is greater than 0.\n;; This is because a valid triangle has the sum of its angles exactly equal to 180 degrees and each angle is greater than 0.\n;; input_format\n;; A single line containing 'True' if the triangle is valid, 'False' otherwise.\n#lang racket\n\n(define (is-valid-triangle angles)\n  (let* ((a (first angles))\n         (b (second angles))\n         (c (third angles)))\n    (and (> a 0) (> b 0) (> c 0) (= (+ a b c) 180))))\n\n(define angles (map string->number (string-split (read-line) \" \")))\n\n(printf \"~a\\n\" (if (is-valid-triangle angles) \"True\" \"False\"))\n    (printf \"False\\n\"))))\n\n(printf \"~a\\n\" (if (is-valid-triangle angles) \"True\" \"False\"))\n    (printf \"False\\n\"))))\n\n(printf \"~a\\n\" (if (is-valid-triangle angles) \"True\" \"False\"))\n    (printf \"False\\n\"))))\n\n(printf \"~a\\n\" (if (is-valid-triangle angles) \"True\" \"False\"))\n    (printf \"False\\n\"))))\n\n(printf \"~a\\n\" (if (is-valid-triangle angles) \"True\" \"False\"))\n    (printf \"False\\n\"))))\n\n(printf \"~a\\n\" (if (is-valid-triangle angles) \"True\" \"False\"))\n    (printf \"False\\n\"))))\n\n(printf \"~a\\n\" (if (is-valid-triangle angles) \"True\" \"False\"))\n    (printf \"False\\n\"))))\n\n(printf \"~a\\n\" (if (is-valid-triangle angles) \"True\" \"False\"))\n    (printf \"False\\n\"))))\n\n(printf \"~a\\n\" (if (is-valid-triangle angles) \"True\" \"False\"))\n    (printf \"False\\n\"))))\n\n(printf \"~a\\n\" (if (is-valid-triangle angles) \"True\" \"False\"))\n    (printf \"False\\n\"))))\n\n(printf \"~a\\n\" (if (is-valid-triangle angles) \"True\" \"False\"))\n    (printf \"False\\n\"))))\n\n(printf \"~a\\n\" (if",
    "inputs": "Six space-separated integers representing the coordinates of three points: x1 y1 x2 y2 x3 y3",
    "outputs": "A single line containing either 'Yes' if the points form a valid triangle, or 'No' otherwise",
    "tests": [
      {
        "input": "1 5 2 5 4 6",
        "output": "Yes"
      },
      {
        "input": "1 1 1 4 1 5",
        "output": "No"
      },
      {
        "input": "1 1 1 1 1 1",
        "output": "No"
      }
    ]
  },
  "solution #49": {
    "solution": "#lang racket\n;; Sort a given list of elements in ascending order using the heap queue algorithm.\n;; A single line containing a list of integers separated by spaces.\n;; A single line containing the sorted integers separated by spaces.Each element is an integer.\n;; Read the input line and split into a list of integers\n(define input (map string->number (string-split (read-line))))\n\n(define sorted (sort input <=))\n(define output (sort input))\n(printf \"~a\\n\" (string-join (map number->string sorted) \" \"))\n(printf \"~a\\n\" output)\n  (printf \"~a\\n\" (sort input <)))\n\n(sort)\n  (displayln (string-join (map number->string sorted) \" \")",
    "unclipped": " Each element is an integer.\n;; Read the input line and split into a list of integers\n(define input (map string->number (string-split (read-line))))\n\n(define sorted (sort input <=))\n(define output (sort input))\n(printf \"~a\\n\" (string-join (map number->string sorted) \" \"))\n(printf \"~a\\n\" output)\n  (printf \"~a\\n\" (sort input <)))\n\n(sort)\n  (displayln (string-join (map number->string sorted) \" \"))))\n\n(sort)\n  (displayln (string-join (map number->string sorted) \" \")))\n\n(sort)\n  (displayln (string-join (map number->string sorted) \" \")))\n\n(sort)\n  (displayln (string-join (map number->string sorted) \" \")))\n\n(sort)\n  (displayln (string-join (map number->string sorted) \" \")))\n\n(sort)\n  (displayln \" \")))\n\n(sort)\n  (displayln (string-join (map number->string sorted) \" \")))\n\n(sort)\n  (displayln -1))\n\n(sort)\n  (displayln -2))\n\n(sort)\n  (displayln -1))\n\n(sort)\n  (displayln -2))\n\n(sort)\n  (displayln -1))\n\n(sort)\n  (displayln -2))\n\n(sort)\n  (displayln -1))\n\n(sort)\n  (displayln -2))\n\n(sort)\n  (displayln -1))\n\n(sort)\n  (displayln -2))\n\n(sort)\n  (displayln -1))\n\n(sort)\n  (displayln -2)))\n\n(sort)\n  (displayln -1))\n\n(sort)\n  (displayln -2))\n\n(sort)\n  (displayln -1)\n  ((newline -1 -2))\n\n(sort)\n  (displayln -1))\n\n(sort)\n  (displayln -2))\n\n(sort)\n  ((newline -1)\n  (displayln -2))\n\n(sort)\n  ((newline -1)\n  ((newline -2))\n\n(sort)\n  ((newline -1)\n  ((newline -2))\n\n(sort)\n  ((newline -1)\n  ((newline -2))\n\n(sort)\n  ((newline -1)\n  ((newline -2))\n\n(sort)\n  ((newline -1)\n  ((newline -2))\n\n(sort)\n  ((newline newline))\n\n(newline)\n  ((newline new-l1)\n  ((newline new-l1))\n\n",
    "inputs": "A single line containing a list of integers separated by spaces.",
    "outputs": "A single line containing the sorted integers separated by spaces.",
    "tests": [
      {
        "input": "18 14 10 9 8 7 9 3 2 4 1",
        "output": "1 2 3 4 7 8 9 9 10 14 18"
      },
      {
        "input": "25 35 22 85 14 65 75 25 58",
        "output": "14 22 25 25 35 58 65 75 85"
      },
      {
        "input": "1 3 5 7 9 2 4 6 8 0",
        "output": "0 1 2 3 4 5 6 7 8 9"
      }
    ]
  },
  "solution #50": {
    "solution": "#lang racket\n;; Given a list of integers, count the number of negative numbers in the list.\n;; A single line containing integers separated by spaces.\n;; A single integer representing the count of negative numbers, followed by a newline.The list is split into a list of integers.\n;; input_format\n;; A single integer representing the count of negative numbers in the list.\n#lang racket\n\n(define (count-negatives input-list)\n  (define count 0)\n  (for ([num (in-list input-list)])\n    (set! count (+ count 1))))\n\n(define input (map string->number (string-split (read-line))))\n(define count (count-negatives input)",
    "unclipped": " The list is split into a list of integers.\n;; input_format\n;; A single integer representing the count of negative numbers in the list.\n#lang racket\n\n(define (count-negatives input-list)\n  (define count 0)\n  (for ([num (in-list input-list)])\n    (set! count (+ count 1))))\n\n(define input (map string->number (string-split (read-line))))\n(define count (count-negatives input))\n(printf \"~a\\n\" count)\n  (displayln count))\n  (number->string count)))\n\n(count-negatives input)\n  (displayln count))\n\n(count-negatives input)\n  (displayln (string-join (map number->string (count-negatives input)) \" \")))\n\n(count-negatives input)\n  (displayln count))\n\n(count-negatives input)\n  (displayln count))\n\n(count-negatives input)\n  (number->string count))\n\n(count-negatives input)\n  (number->string count))\n\n(count-negatives input)\n  (number->string count))\n\n(count-negatives input)\n  (number->string count))\n\n(count-negatives input)\n  (number->string count))\n\n(count-negatives input)\n  (number->string count))\n\n(count-negatives input)\n  (number->string count))\n\n(count-negatives input)\n  (number->string count))\n\n(count-negatives input)\n  (number->string count))\n\n(count-negatives input)\n  (number->string count))\n\n(count-negatives input)\n  (number->string count))\n\n(count-negatives input)\n  (number->string count))\n\n(count-negatives input)\n  (number->string count))\n\n(count-negatives input)\n  (number->string count))\n\n(count-negatives input)\n  (number->string count))\n\n(count-negatives input)\n  (number->string count))\n\n(count-negatives input)\n  (number->string count))\n\n(count-negatives input)\n  (number->string count))\n\n(count-negatives input)\n  (number->string n))\n\n(count-negatives input)\n  (number->string n))\n\n(count-negatives input)\n  (number->string n))\n\n(count-negatives input)\n  (number->string n))\n\n(count-negatives input)\n  (number->string n))\n\n(count-negatives input)\n  (number->string n))\n\n(count-negatives input)\n  (number->",
    "inputs": "A single line containing integers separated by spaces.",
    "outputs": "A single integer representing the count of negative numbers, followed by a newline.",
    "tests": [
      {
        "input": "-1 -2 3 -4 -5",
        "output": "4"
      },
      {
        "input": "1 2 3",
        "output": "0"
      },
      {
        "input": "1 2 -3 -10 20",
        "output": "2"
      }
    ]
  }
}